#+TITLE: Assert-Statements-in-Python
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2017-03-14 äºŒ 02:39]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

#+URL: https://dbader.org/blog/python-assert-tutorial

å¦‚ä½•åˆ©ç”¨æ–­è¨€è‡ªåŠ¨æŽ¢æµ‹Pythonç¨‹åºä¸­çš„é”™è¯¯ä½¿ä¹‹æ›´å¯é ä¸”æ˜“äºŽè°ƒè¯•.

[[https://dbader.org/blog/figures/python-assert.png]]

* ä»€ä¹ˆæ—¶æ–­è¨€ & æ–­è¨€æ“…é•¿ä»€ä¹ˆ?

Pythonçš„ =assert= è¯­å¥å¯ä»¥ç”¨äºŽè°ƒè¯•. å®ƒä¼šæµ‹è¯•ä¸€ä¸ªæ¡ä»¶,è‹¥è¿™ä¸ªæ¡ä»¶ä¸ºçœŸ,åˆ™å®ƒä»€ä¹ˆä¹Ÿä¸åš,ä½ çš„ç¨‹åºç…§å¸¸å¾€ä¸‹æ‰§è¡Œ.
ä½†è‹¥æ¡ä»¶ä¸ºå‡,åˆ™å®ƒä¼šæŠ›å‡ºä¸€ä¸ª =AssertionError= å¼‚å¸¸,è¯¥å¼‚å¸¸ç”šè‡³è¿˜èƒ½åŒ…æ‹¬ä¸€ä¸ªé”™è¯¯ä¿¡æ¯.

=assertions= çš„æ­£ç¡®ä½¿ç”¨æ–¹æ³•æ˜¯ç”¨å®ƒæ¥é€šçŸ¥å¼€å‘è€…ç¨‹åºä¸­å‡ºçŽ°äº†æ— æ³•å›žå¤çš„å¼‚å¸¸. 
ä½ ä¸èƒ½ç”¨å®ƒæ¥å¤„ç†ç±»ä¼¼"æ–‡ä»¶æ²¡æ‰¾åˆ°"è¿™ç±»å¯ä»¥é¢„è§çš„é”™è¯¯,å› ä¸ºç”¨æˆ·å¯ä»¥é‡‡å–è¡ŒåŠ¨ä¿®æ­£è¿™ä¸€é”™è¯¯,ç„¶åŽé‡è¯•.

å¦ä¸€ç§çœ‹æ³•æ˜¯æŠŠ =assertions= çœ‹æˆæ˜¯ç¨‹åºçš„å†…éƒ¨æ£€æŸ¥å·¥å…·.
å®ƒæ ‡æ³¨æŸäº›æƒ…å†µæ˜¯ä¸å¯èƒ½åœ¨ä»£ç ä¸­å‡ºçŽ°çš„. å¦‚æžœçœŸçš„å‡ºçŽ°äº†å…¶ä¸­çš„æƒ…å†µ,é‚£è¡¨ç¤ºç¨‹åºä¸­è‚¯å®šæœ‰bug.

è‹¥ä½ çš„ç¨‹åºä¸­æ²¡æœ‰bug, å°±ä¸ä¼šè§¦å‘è¿™äº›æ¡ä»¶. ä½†å¦‚æžœçœŸçš„è§¦å‘äº†è¿™äº›æ¡ä»¶,é‚£ä¹ˆç¨‹åºå°±ä¼šå´©æºƒ,å¹¶æ˜¾ç¤ºä¸€æ¡æ–­è¨€é”™è¯¯ä¿¡æ¯å‘Šè¯‰ä½ æ˜¯è§¦å‘äº†å“ªä¸€æ¡"ä¸è¯¥å‡ºçŽ°çš„"æ¡ä»¶.
è¿™æœ‰åˆ©äºŽè¿½è¸ªå’Œä¿®å¤bug.

æ€»ç»“èµ·æ¥å°±æ˜¯: Pythonçš„ =assert= æ˜¯ä¸€ç§è°ƒè¯•çš„å·¥å…·è€Œä¸é€‚äºŽç”¨æ¥å¤„ç†è¿è¡Œæ—¶é”™è¯¯çš„.
ä½¿ç”¨æ–­è¨€æ˜¯ä¸ºäº†è®©å¼€å‘è€…å¿«é€Ÿæ‰¾åˆ°bugäº§ç”Ÿçš„æ ¹æº.
åº”è¯¥è¦åšåˆ°åªæœ‰å½“ä½ çš„ç¨‹åºä¸­å‡ºçŽ°bugæ—¶æ‰èƒ½æŠ›å‡ºæ–­è¨€é”™è¯¯.

* Pythonä¸­çš„Assert â€” ä¸¾ä¸ªä¾‹å­

ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­,å±•ç¤ºä¸€ä¸‹æ–­è¨€åº”è¯¥æ€Žä¹ˆç”¨.
æˆ‘å°½é‡è®©è¿™ä¸ªä¾‹å­æ›´å®žé™…ä¸€ç‚¹.

å‡è®¾ä½ åœ¨ç”¨Pythonæ­å»ºä¸€ä¸ªåœ¨çº¿å•†åœº. ä½ éœ€è¦ä¸ºå®ƒæ·»åŠ ä¸€é¡¹æŠ˜æ‰£åˆ¸çš„åŠŸèƒ½å› æ­¤å†™äº†ä¸‹é¢è¿™ä¸ª =apply_discount= åŠŸèƒ½:

#+BEGIN_SRC python
  def apply_discount(product, discount):
      price = int(product['price'] * (1.0 - discount))
      assert 0 <= price <= product['price']
      return price
#+END_SRC

æ³¨æ„åˆ°äº†é‚£ä¸ª =assert= è¯­å¥äº†ä¹ˆ? å®ƒä¼šä¿è¯,ä¸ç®¡æ€Žä¹ˆæ ·,æ‰“æŠ˜åŽçš„ä»·æ ¼éƒ½ä¸ä¼šä½ŽäºŽ0å…ƒ,ä¹Ÿä¸ä¼šé«˜äºŽåŽŸä»·.

è®©æˆ‘ä»¬ç”¨å„ç§æŠ˜æ‰£æ¥è°ƒç”¨è¯¥å‡½æ•°,ç¡®ä¿è¯¥å‡½æ•°èƒ½å¦‚æˆ‘ä»¬æ‰€æ„¿é‚£è¾¹åœ°æ­£å¸¸å·¥ä½œ.

#+BEGIN_SRC python
  #
  # Our example product: Nice shoes for $149.00
  #
  >>> shoes = {'name': 'Fancy Shoes', 'price': 14900}

  #
  # 25% off -> $111.75
  #
  >>> apply_discount(shoes, 0.25)
  11175
#+END_SRC

ä¸é”™,æŒºæ­£å¸¸çš„. çŽ°åœ¨å†è¯•è¯•å…¶ä»–éžæ³•çš„æŠ˜æ‰£:

#+BEGIN_SRC python
  #
  # A "200% off" discount:
  #
  >>> apply_discount(shoes, 2.0)
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
      apply_discount(prod, 2.0)
    File "<input>", line 4, in apply_discount
      assert 0 <= price <= product['price']
  AssertionError

  #
  # A "-30% off" discount:
  #
  >>> apply_discount(shoes, -0.3)
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
      apply_discount(prod, -0.3)
    File "<input>", line 4, in apply_discount
      assert 0 <= price <= product['price']
  AssertionError
#+END_SRC

å¦‚ä½ æ‰€è§,å½“ä¼ å…¥ä¸€ä¸ªéžæ³•çš„æŠ˜æ‰£æ—¶ä¼šå¼•å‘ =AssertionError= å¼‚å¸¸,å¹¶æŒ‡å‡ºå¼‚å¸¸çš„è¡Œä»¥åŠä¸åŒ¹é…çš„æ–­è¨€æ¡ä»¶.
å½“æˆ‘ä»¬åœ¨æµ‹è¯•åœ¨çº¿å•†åœºæ—¶,è‹¥å‡ºçŽ°äº†è¿™ç§é”™è¯¯,é€šè¿‡æŸ¥çœ‹ traceback å¯ä»¥å¾ˆæ–¹ä¾¿åœ°æ‰¾å‡ºé”™è¯¯åŽŸå› .

è¿™å°±æ˜¯æ–­è¨€çš„å¨åŠ›.

* Pythonâ€™s Assert Syntax

å¼€å§‹ä½¿ç”¨æŸé¡¹è¯­è¨€ç‰¹æ€§å‰æœ€å¥½å…ˆäº†è§£å®ƒæ˜¯å¦‚ä½•å®žçŽ°çš„. ä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹ä¸€ä¸‹ [[https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement][Pythonæ–‡æ¡£ä¸­assertè¯­å¥çš„è¯­æ³•æ˜¯æ€Žæ ·çš„]]:

#+BEGIN_SRC python
  assert_stmt ::= "assert" expression1 ["," expression2]
#+END_SRC

å…¶ä¸­ =expression1= å°±æ˜¯æˆ‘ä»¬è¦æµ‹è¯•çš„æ¡ä»¶, è€Œå¯é€‰çš„ =expression2= æ˜¯æ–­è¨€å¤±è´¥æ—¶è¦æ˜¾ç¤ºçš„é”™è¯¯ä¿¡æ¯.

åœ¨æ‰§è¡ŒæœŸé—´,Pythonè§£é‡Šå™¨ä¼šå°†æ¯ä¸ª =assert= è¯­å¥éƒ½è½¬æ¢æˆç±»ä¼¼ä¸‹é¢è¿™æ ·:

#+BEGIN_SRC python
  if __debug__:
      if not expression1:
          raise AssertionError(expression2)
#+END_SRC

ä½ ä¹Ÿå¯ä»¥é€šè¿‡ =expression2= ä¼ é€’ä¸€ä¸ªå¯é€‰çš„é”™è¯¯ä¿¡æ¯, å½“è§¦å‘ =AssertionError= å¼‚å¸¸æ—¶, è¯¥é”™è¯¯ä¿¡æ¯ä¹Ÿä¼šä¸€åŒåœ¨ traceback ä¸­æ˜¾ç¤ºå‡ºæ¥.
å®ƒå¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–è°ƒè¯•. ä¸¾ä¸ªä¾‹å­,æˆ‘æ›¾è§è¿‡è¿™æ ·çš„ä»£ç :

#+BEGIN_SRC python
  if cond == 'x':
      do_x()
  elif cond == 'y':
      do_y()
  else:
      assert False, ("This should never happen, but it does occasionally. "
                     "We're currently trying to figure out why. "
                     "Email dbader if you encounter this in the wild.")
#+END_SRC

è¿™æ®µä»£ç ä¸‘å—? æ˜¯çš„,çš„ç¡®å¾ˆä¸‘. ä½†æ˜¯å½“ä½ é‡è§ [[https://en.wikipedia.org/wiki/Heisenbug][heisenbug-type issue]] è¿™æ ·çš„é—®é¢˜æ—¶,è¿™ç§æŠ€æœ¯éƒ½å¾ˆæœ‰ç”¨äº†. ðŸ˜‰

* Common Pitfalls With Using Asserts in Python

Before you move on, there are two important caveats with using assertions in
Python that Iâ€™d like to call out.

The first one has to do with introducing security risks and bugs into your
applications, and the second one is about a syntax quirk that makes it easy to
write useless assertions.

This sounds (and potentially is) pretty horrible, so you might at least want
to skim these two caveats or read their summaries below.

** Caveat #1 â€“ Donâ€™t Use Asserts for Data Validation

*Asserts can be turned off globally in the Python interpreter. Donâ€™t rely on assert expressions to be executed for data validation or data processing.*

The biggest caveat with using asserts in Python is that [[https://docs.python.org/3/library/constants.html#__debug__][assertions can be]]
[[https://docs.python.org/3/library/constants.html#__debug__][globally disabled]] with the -O and -OO command line switches, as well as the
PYTHONOPTIMIZE environment variable in CPython.

This turns any assert statement into a null-operation: the assertions simply
get compiled away and wonâ€™t be evaluated, which means that none of the
conditional expressions will be executed.

This is an intentional design decision used similarly by many other
programming languages. As a side-effect it becomes extremely dangerous to use
assert statements as a quick and easy way to validate input data.

Let me explainâ€”if your program uses asserts to check if a function argument
contains a â€œwrongâ€ or unexpected value this can backfire quickly and lead to
bugs or security holes.

Letâ€™s take a look at a simple example. Imagine youâ€™re building an online store
application with Python. Somewhere in your application code thereâ€™s a function
to delete a product as per a userâ€™s request:

#+BEGIN_SRC python
  def delete_product(product_id, user):
      assert user.is_admin(), 'Must have admin privileges to delete'
      assert store.product_exists(product_id), 'Unknown product id'
      store.find_product(product_id).delete()
#+END_SRC

Take a close look at this function. What happens if assertions are disabled?

There are two serious issues in this three-line function example, caused by
the incorrect use of assert statements:

 1. Checking for admin privileges with an assert statement is dangerous. If
    assertions are disabled in the Python interpreter, this turns into a
    null-op. Therefore any user can now delete products. The privileges check
    doesnâ€™t even run. This likely introduces a security problem and opens the
    door for attackers to destroy or severely damage the data in your
    customerâ€™s or companyâ€™s online store. Not good.
 2. The product_exists() check is skipped when assertions are disabled. This
    means find_product() can now be called with invalid product idsâ€”which
    could lead to more severe bugs depending on how our program is written. In
    the worst case this could be an avenue for someone to launch Denial of
    Service attacks against our store. If the store app crashes if we attempt
    to delete an unknown product, it might be possible for an attacker to
    bombard it with invalid delete requests and cause an outage.

How might we avoid these problems? The answer is to not use assertions to do
data validation. Instead we could do our validation with regular if-statements
and raise validation exceptions if necessary. Like so:

#+BEGIN_SRC python
  def delete_product(product_id, user):
      if not user.is_admin():
          raise AuthError('Must have admin privileges to delete')

      if not store.product_exists(product_id):
          raise ValueError('Unknown product id')

      store.find_product(product_id).delete()
#+END_SRC

This updated example also has the benefit that instead of raising unspecific
AssertionError exceptions, it now raises semantically correct exceptions like
ValueError or AuthError (which [[https://dbader.org/blog/python-custom-exceptions][weâ€™d have to define ourselves]]).

** Caveat #2 â€“ Asserts That Never Fail

Itâ€™s easy to accidentally write Python assert statements that always evaluate
to true. Iâ€™ve been bitten by this myself in the past. I wrote [[https://dbader.org/blog/catching-bogus-python-asserts][a longer article]]
[[https://dbader.org/blog/catching-bogus-python-asserts][about this specific issue you can check out by clicking here]].

Alternatively, hereâ€™s the executive summary:

*When you pass a tuple as the first argument in an assert statement, the assertion always evaluates as true and therefore never fails.*

For example, this assertion will never fail:

#+BEGIN_SRC python
  assert(1 == 2, 'This should fail')
#+END_SRC

This has to do with non-empty tuples always being truthy in Python. If you
pass a tuple to an assert statement it leads to the assert condition to always
be trueâ€”which in turn leads to the above assert statement being useless
because it can never fail and trigger an exception.

Itâ€™s relatively easy to accidentally write bad multi-line asserts due to this
unintuitive behavior. This quickly leads to broken test cases that give a
false sense of security in our test code. Imagine you had this assertion
somewhere in your unit test suite:

#+BEGIN_SRC python
  assert (
      counter == 10,
      'It should have counted all the items'
  )
#+END_SRC

Upon first inspection this test case looks completely fine. However, this test
case would never catch an incorrect result: it always evaluates to True,
regardless of the state of the counter variable.

Like I said, itâ€™s rather easy to shoot yourself in the foot with this (mine
still hurts). Luckily, there are some countermeasures you can apply to prevent
this syntax quirk from causing trouble:

[[https://dbader.org/blog/catching-bogus-python-asserts][>> Read the full article on bogus assertions to get the dirty details.]]

* Python Assertions â€” Summary

Despite these caveats I believe that Pythonâ€™s assertions are a powerful
debugging tool thatâ€™s frequently underused by Python developers.

Understanding how assertions work and when to apply them can help you write
more maintainable and easier to debug Python programs. Itâ€™s a great skill to
learn that will help bring your Python to the next level and make you a more
well-rounded Pythonista.
