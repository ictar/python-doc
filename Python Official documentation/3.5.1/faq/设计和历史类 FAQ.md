# 设计和历史类 FAQ

原文： [Design and History FAQ](https://docs.python.org/3/faq/design.html)

---

## 为什么Python使用缩进对语句进行分组？
Guido van Rossum认为使用缩进进行分组是极为优雅的，它大大有助于Python程序的平均清晰度。学了一段时间后，大多数人都会喜欢这个功能。

因为没有开始/结束括号，所以不可能有解析器和人类读者之间分组感知的分歧。偶尔，C程序员会遇到这样的代码片段：
```python
if (x <= y)
        x++;
        y--;
z++;
```
如果条件为真，那么只有`x++`语句会被执行，但缩进让你相信应该是另一种情况。即使是经验丰富的C程序员有时也会盯着它很长一段时间，不知道为什么即使对于`x>y`，`y`也在递减。

因为没有开始/结束括号，Python是不太容易导致编码风格的冲突。在C语言中，有很多不同的方式来放置括号。如果你已经习惯了使用一种风格来阅读和写作代码，那么当阅读读（或者被要求写）另一种风格的时候，至少你会略有不安。

许多编码风格地方去单独用一行放置开始/结束括号。这使得程序更长，而且浪费宝贵的屏幕空间，使其更难以得到程序的一个很好的概述。理想情况下，一个函数应该适合在一个屏幕上（例如，20-30行）。20行的Python可以比20行的C做更多的工作。这不仅仅是因为缺乏开始/结束括号 - 也有缺乏声明和高层次的数据类型的原因 - 但当然也与基于缩进的语法有关。

## 为什么使用简单的算术运算会出现奇怪的结果？
见下一个问题。

## 为什么浮点计算如此不准确？
用户往往惊讶于这样的结果：
```
>>> 1.2 - 1.0
0.19999999999999996
```
并认为这是Python中的一个错误。然而并不是。它有一点与Python有关，但更多的是底层平台如何处理浮点数。

CPython中的[float](https://docs.python.org/3/library/functions.html#float)类型使用C的`double`类型进行存储。一个[float](https://docs.python.org/3/library/functions.html#float)对象的值存储在二进制浮点中，并具有固定精度（通常为53位），而Python使用C的操作，这又依赖对于浮点运算的执行，处理器的硬件实现。这意味着，只要对于浮点运算，Python的行为就像许多流行语言一样，包括C和Java。

Many numbers that can be written easily in decimal notation cannot be expressed exactly in binary floating-point. For example, after:许多可以很容易地用十进制格式表示的数字可以不完全以二进制浮点表示。例如，执行下面操作后：

`>>> x = 1.2`

存储在`x`中的值是一个（非常好的）十进制值 `1.2`近似值，但并不完全等于它。在典型的机器中，实际存储的值是：

`1.0011001100110011001100110011001100110011001100110011 (binary)`

这正是：

`1.1999999999999999555910790149937383830547332763671875 (decimal)`

53位典型的精确度提供了Python中精度为15-16位小数的浮点类型。

获取更充分的说明，请见Python教程中[浮点运算](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues)章节。

## 为什么Python字符串不可变？
有若干优点。

优点之一是性能：字符串不可变意味着我们可以在创建时为它分配空间，并且存储需求是固定不变的。这也是元组和列表之间的区别的原因之一。

另一个优点是，Python中的字符串如数字一样被认为是“基本元素”。再多的行为也不会将数值`8`修改为其他东西，而在Python中，再多的行为也不会将字符串"eight"修改为其他东西。

## 为什么一定要在方法定义和调用中显示的使用"self"呢？
此想法借于Modula-3。出于各种原因，它被证明是非常有用的。

首先，比较明显的是，你正在使用的是一个方法或一个实例属性，而不是一个局部变量。当看到`self.x`或`self.meth（）`时，即使心里不清楚类定义，你也会绝对清楚地知道使用的是一个实例变量或方法。在C++中，您可以通过缺少局部变量声明来稍微辨别（假设全局很少或很容易辨认） - 但在Python中，并没有本地变量声明，所以为了确定，你必须要查找类定义。一些C ++和Java编码标准要求实例属性有一个`m_`前缀，所以这个明确性在那些语言中仍然很有用。

其次，它意味着，如果你想明确地引用或调用特定类的方法，并不需要特殊的语法。在C++中，如果你想使用基类中被派生类重写的方法，你必须使用`::`操作符 - 在Python中，你可以写 `baseclass.methodname(self, <argument list>)`。这对于[__init__()](https://docs.python.org/3/reference/datamodel.html#object.__init__)方法以及派生类方法想要扩展具有相同名字的基类方法，并因此必须以某种方式调用基类方法的一般情况特别有用

最后，对于实例变量，它解决了一个赋值的语法问题：因为（按照定义！）Python中的局部变量是那种在函数体中赋值的变量（并没有明确的声明为全局），所以必须有某种方式告诉解释器，赋值操作是要将值赋给一个实例变量，而不是一个本地变量，并且（出于效率的考虑），它最好是语法。C++通过声明做到这一点，但是Python并没有声明，并且如果只是为了这个目的而将其引进，这将是一个遗憾。显式地使用`self.var`很好地解决了这个问题。同样，对于实例变量的使用，必须写`self.var`意味着，对一个方法中不合格的名称的引用，不必搜索实例的目录。换句话说，局部变量和实例变量处于两个不同的命名空间，而你需要告诉Python使用哪一个命名空间。

## 为什么不能在一个表达式中使用赋值？
许多习惯于C或者Perl的人抱怨说，他们想使用这个C的习惯：
```
while (line = readline(f)) {
    // do something with line
}
```
而在Python中，你不得不这样写：
```
while True:
    line = f.readline()
    if not line:
        break
    ... # do something with line
```
之所以不允许在Python表达式中进行赋值，是因为在其他许多语言中，由此结构引起的一种常见并且难以发现的错误：
```
if (x = 0) {
    // error handling
}
else {
    // code that only works for nonzero x
}
```
这个错误是一个简单的打字错误：`x = 0`，它将0赋给变量`x`，而真实意图却是要进行比较：`x == 0`。

许多替代方案已经被提出。大多数是节省一些打字，但是使用任意的或隐蔽的语法或关键字的讨巧做法，但是出于这样一个对于语言修改建议的简单的标准，它们都失败了：对于一个尚未被引入到此结构的人类读者，它应该直观的显示应有之义。

一个有趣的现象是，最有经验的Python程序员都承认`while True`习语，并且似乎并不很想念在表达式中进行赋值的构造; 具有强烈愿望想将它添加到该语言中的，只有新人。

有另一种看起来有吸引力的拼写方式，但通常比“while True”方案缺乏健壮性：
```
line = f.readline()
while line:
    ... # do something with line...
    line = f.readline()
```
这样做的问题是，如果你改变了如何获取下一行的想法（例如，你想把它变成`sys.stdin.readline()`），那么你必须记住要改变你的程序中的两次 - 第二次出现被隐藏在循环的底部。

最好的办法是通过使用迭代器，从而使其能够使用`for`语句来循环对象。例如，文件对象支持迭代器协议，所以你可以简单地这样写：
```
for line in f:
    ... # do something with line...
```
## 为什么对一些功能，Python使用方法（例如，list.index()），对另一些功能，Python使用函数（例如，len(list)）？
主要是历史原因。函数被用于这样的操作，它们对于一组类型通用，并且意在即使对于那些完全没有方法的对象（例如元组）也能工作。当您使用Python的功能性特征时（`map()`, `zip()`等），拥有一个可以很容易地应用到对象的无定形集合上的函数也是方便的。

事实上，作为内置函数实现`len()`，`max()`，`min()`比作为用于每种类型的方法实现它们的代码实际上少。人们可以狡辩个别情况，但它是Python中的一部分，并且现在它已经来不及做出这种根本性的变化了。该功能必须保持以避免大量的代码破损。

>**注意**： 对于字符串操作，Python已经将外部函数（`string`模块）移动成方法了。然而，`len()`仍是一个函数。

## 为什么join()是一个字符串方法，而不是一个列表或元组方法？
从Python 1.6开始，当添加了提供与字符串模块中的函数相同功能的方法，字符串变得更加像其他的标准类型。大多数这些新方法已被广泛接受，但还有一个方法，它的出现使一些程序员感到不舒服：

`", ".join(['1', '2', '4', '8', '16'])`

它给出这样的结果：

`"1, 2, 4, 8, 16"`

有两种反对这种使用的常见观点。

第一种对于可能是，但一个字符串仅仅是一个固定值的答案的范畴进行延伸：“使用字符串字面量（字符串常量）的方法看起来真丑”。如果将名称绑定到字符串上的方法被允许，那么就没有逻辑原因使它们对文字不可用。

第二个反对理由通常可以转换为：“我真的讲一个使用字符串常量将序列的成员连接在一起的序列”。可悲的是，你不是。出于某种原因，似乎作为字符串方法拥有[split()](https://docs.python.org/3/library/stdtypes.html#str.split)会比较容易得多，因为在那种情况下，很容易看出：

`"1, 2, 4, 8, 16".split(", ")`

是一个返回一个字符串中，由给定分隔符（或在默认情况下，任意多个空格）分隔的子字符串。

[join()](https://docs.python.org/3/library/stdtypes.html#str.join)是一个字符串方法，因为使用它的时候，你告诉分隔符字符串去遍历一个字符串序列，并且将其自身插入到相邻的元素中。这个方法可以用于任何遵守序列对象规则的参数，包括你自己可能定义的任何新的类。类似的方法存在于byte和bytearray对象中。

## 异常有多快？
如果没有触发异常，try/except是非常有效的。其实，捕获异常昂贵。在Python 2.0之前的版本，常常会使用下面如下习语：
```
try:
    value = mydict[key]
except KeyError:
    mydict[key] = getvalue(key)
    value = mydict[key]
```
这只有当你预期在几乎所有的时间内，字典都有键时才有意义。如果不是的话，你像这样的进行编码：
```
if key in mydict:
    value = mydict[key]
else:
    value = mydict[key] = getvalue(key)
```
对于这个特定的情况，你也可以使用`value = dict.setdefault(key, getvalue(key))`，但前提是`getvalue()`调用足够廉价，因为它是在所有的情况下进行评估的。

## 为什么Python中没有一个switch或者case语句？
你可以通过使用`if... elif... elif... else`序列很容易的做到这点。已经有一些关于`switch`语法的建议，但就是否以及如何进行范围测试（还）没有达成共识。参阅[PEP 275](https://www.python.org/dev/peps/pep-0275)以获得完整的细节和当前状态。

对于需要从大量的可能性中进行选择的情况下，你可以创建一个字典，将每个情况下的值映射到函数调用。例如：
```
def function_1(...):
    ...

functions = {'a': function_1,
             'b': function_2,
             'c': self.method_1, ...}

func = functions[value]
func()
```
对于调用对象的方法，通过使用内置[getattr()](https://docs.python.org/3/library/functions.html#getattr)来使用特定名称进行方法检索，可以进一步简化：
```
def visit_a(self, ...):
    ...
...

def dispatch(self, value):
    method_name = 'visit_' + str(value)
    method = getattr(self, method_name)
    method()
```
建议为方法名称使用一个前缀，诸如这个例子中的`visit_`。如果没有这样的前缀，如果值是来自不受信任的来源，那么攻击者能够对你的对象调用任何方法。

## 为什么不能在解释器中模拟线程以取代依靠一个操作系统指定的线程实现呢？
答案1：不幸的是，解释器为每个Python的堆栈帧争取至少一个C堆栈帧。此外，在几乎是随机的瞬间，扩展可以回调到Python。因此，一个完整的线程实现需要C的线程支持。

答案2：幸运的是，有一个无堆栈的Python，它有一个完全重新设计的解释器，其避免了C堆栈。

## 为什么lambda表达式不能包含语句？
Python的lambda表达式不能包含语句，因为Python的语法框架不能处理嵌套在表达式中的语句。然而，在Python中，这不是一个严重的问题。不像在其他语言中的lambda形式（它们增加功能），如果你懒得去定义一个函数，Python的lambda表达式只是一个速记符号。

函数已经是Python的第一类对象，并且可以在局部范围内声明。因此，使用一个lambda，而不是本地定义函数的唯一的好处是，你并不需要为此函数发明的一个名字 - 但是这只是，分配该函数对象（与lambda表达式声明的完全同一类型的对象）的一个局部变量！

## Python可以被编译成机器码，C或者其他语言吗？
现实的答案是：

[Cython](http://cython.org/)和[Pyrex](http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/)将一个具有可选注释的修改后的Python版本编译成C扩展。 交织(weave)可以很容易地以各种方式交融Python和C代码来提高性能 。Nuitka是一个Python到C ++代码的崭露头角的编译器，旨在支持完整的Python语言。

理论答案是：

没那么简单。Python的高级数据类型，对象的动态类型以及解释器在运行时调用（使用[eval()](https://docs.python.org/3/library/functions.html#eval)或[exec()](https://docs.python.org/3/library/functions.html#exec)）一起意味着，一个天真的“已编译”Python程序很可能会主要包括到Python运行时系统的调用，即使是对于像`x+1`的看似简单的操作。

在Python新闻组或过去的Python会议中描述的几个项目已经表明，这种方法是可行的，虽然到目前为止达到的加速只是温和的（比如，2x）。Jython使用相同的策略来将其编译成Java字节码。（Jim Hugunin已经证明，与整个程序分析相结合，对于小型演示方案，1000倍的速度提升是可行的。参阅[the proceedings from the 1997 Python conference](http://legacy.python.org/workshops/1997-10/proceedings/)，以获取更多信息。）

## Python如何进行内存管理？
Python的内存管理的细节取决于实现。Python的标准实现，[CPython](https://docs.python.org/3/glossary.html#term-cpython)，使用引用计数来检测不可访问的对象，以及另一种机制来收集引用周期，定期执行周期检测算法，来寻找不可访问周期和删除涉及到的对象。[gc](https://docs.python.org/3/library/gc.html#module-gc)模块提供了执行垃圾回收的函数，获得调试数据的函数，以及调整收集器参数的函数。

然而，其他实现方式（如[Jython](http://www.jython.org/)或 [PyPy](http://www.pypy.org/)），依赖于不同的机制，例如一个成熟的垃圾收集器。如果你的Python代码依赖于引用计数实现的行为，那么这种差异可能会导致一些微妙的移植问题。

在一些Python实现中，下面的代码（在CPython中是没问题的）可能会用尽文件描述符：
```
for file in very_long_list_of_files:
    f = open(file)
    c = f.read(1)
```
事实上，使用CPython的引用计数和析构函数方案，每次对f的新赋值会关闭前一个文件。但是，使用传统的GC，这些文件对象只会在不同的并且可能长的时间间隔内被收集（并关闭）。

如果要编写能够与任何Python实现一起工作的代码，你应该明确地关闭文件，或者使用[with](https://docs.python.org/3/reference/compound_stmts.html#with)语句;那么不管内存管理方案如何，它都将工作：
```
for file in very_long_list_of_files:
    with open(file) as f:
        c = f.read(1)
```

## 为什么CPython使用一个更加传统的垃圾回收机制？
一方面，这不是C标准功能，因此它是不可移植的。（是的，我们了解Boehm的GC库。对于最常见的平台，而不是对于所有的平台，它有汇编代码位，虽然它几乎都是透明的，但是它不是完全透明的，Python要与它共同工作，则需要补丁。）

当Python被嵌入到其他应用程序中时，传统的GC也成为了一个问题。虽然在独立的Python中，使用GC库的版本来替换标准的malloc()和free()并无问题，但是嵌入Python的应用程序可能想要有它自己对malloc()和free()的替代，而不是Python的。眼下，CPython与任何恰当实现的malloc()和free()工作良好。

## 为什么在CPython退出时不将所有内存释放？
当Python退出时，从Python模块的全局命名空间中引用的对象不会总是被释放。如果有循环引用，那么则可能发生这种情况。也有某些C库分配的内存位是无法被释放的（如，像Purify之类的工具会抱怨这些）。然而，Python会在退出时积极地清理内存，并试图摧毁每一个对象。

如果要强制Python在释放时删除某些东西，那么使用[atexit](https://docs.python.org/3/library/atexit.html#module-atexit)模块来运行一个强制删除的函数。

## 为什么会有单独的元组和列表数据类型？
列表和元组，在许多方面相似，但是它们通常以根本不同的方式被使用。元组可以被看作是类似于Pascal的记录或C结构; 它们是相关的数据的小集合，这些数据可能具有不同的类型，并作为一组进行操作。例如，笛卡尔坐标被适当地表示为两个或三个数字的一个元组。

列表，在另一方面，更像其他语言中的数组。它们倾向于保持不同数量的对象，它们都具有相同的类型，并一个接一个地被操作。例如，`os.listdir('.')`返回表示在当前目录中的文件的字符串列表。如果您添加一两个其他文件到此目录，对此输出进行操作的函数一般不会中途退出。

元组是不可变的，这意味着一旦一个元组被创建，你不能用一个新值取代它的任何元素。列表是可变的，这意味着你可以随时更改列表的元素。只有不可变元素可以被用作字典键，因此仅元组而不是列表可以被用作键。

## 如何实现列表？
Python的列表是真正的变长数组，而不是Lisp风格的链接列表。该实现使用一个包含对其他对象的引用的连续数组，并在一个列表头部结构中保持一个指向这个数组和该数组长度的指针。

这使得列表的索引操作`a[i]`操作的消耗独立于该列表的长度或者索引的值。

当追加或插入项时，引用的数组会调整大小。一些技巧被用于提高连续追加项的操作的性能；当必须增长数组时，会分配一些额外的空间，以便接下来的几次不要求实际调整大小。

## 如何实现字典？
Python的字典被实现为可调整大小的哈希表。相比于B-树，这在大多数情况下为查找提供了更好的性能（迄今为止最常见的操作），并且实现更简单。

字典通过使用内置的[hash()](https://docs.python.org/3/library/functions.html#hash)函数计算存储在字典中的每个键的哈希码。哈希码的差别很大取决于键和每个进程的种子(seed)。例如，“Python”可能散列为-539294296，而“python”，相差一个位的字符串，可以散列到1142331976。然后，哈希码被用来计算在内部数组中的位置，值将被存储在这个位置。假设你存储的所有的键都有不同的hash值，这意味着词典需要花费常数时间- O(1)，在计算机科学记数法的角度 - 来检索一个键。这也意味着，不需要维护键的排序顺序，并且使用`.keys()`和`.items()`遍历数组将以某个任意混乱的顺序输出字典的内容，此顺序在每次函数的调用都会改变。

## 为什么字典键是不可变的？
哈希表实现的字典使用从键值计算得到的哈希值来找到键。如果该键是可变对象，那么它的值是可以改变的，因此它的散列也可以改变。但是，由于无论谁改变键对象都不能说它是作为字典的键被使用的，那么就不能在字典中到处移动项。然后，当您尝试查找在字典中的同一对象，将不会找到，因为它的哈希值是不同的。如果你想查找旧值，那也将无法找到，因为在那个哈希bin中找到的对象的值会有所不同。

如果你想用一个列表索引的字典，那么首先简单地转换列表为元组; 函数`tuple(L)`创建一个具有与列表L相同条目的一个元组。元组是不可变的，因此可以作为字典键。

已经提出了一些不能接受的解决方案：

* 由它们的地址（对象ID）散列的列表。这行不通，因为如果你使用相同的值来建立一个新的列表，那么它将不会被发现; 例如：
    ```
    mydict = {[1, 2]: '12'}
    print(mydict[[1, 2]])
    ```
    将引发KeyError异常，因为在第二行中使用的`[1，2]`的id 不同于第一行。换言之，字典的键应该使用`==`进行比较，而不使用`is`。

* 当使用列表作为键时，进行拷贝。这不起作用，因为该列表是一个可变对象，它可以包含一个指向自己的引用，然后复制代码将运行一个无限循环。

* 允许列表作为键，但告诉用户不要修改它们。当你忘记或意外修改列表时，这将允许程序中的一类难以跟踪的错误。它也使字典的一个重要不变项无效：在`d.keys()`中的每一个值作为字典键可用。

* 一旦被用作字典的键，则将列表标记为只读。问题是，它不只是可以改变其数值的顶层对象; 你可以使用包含列表的元组作为一个键。任何作为一个键被输入到字典中，将需要标记所有的对象作为只读对象可达 - 并且再次，自引用对象可能会引发一个无限循环。

如果你需要，还有一个窍门来解决这个问题，但是使用它需要您自担风险：你可以在一个同时具有[__eq __()](https://docs.python.org/3/reference/datamodel.html#object.__eq__)和[__hash __](https://docs.python.org/3/reference/datamodel.html#object.__hash__)方法的类实例中包装一个可变结构。然后，您必须确保所有这些包装对象的哈希值驻留在一个字典（或其它基于散列的结构）中，当对象在字典（或其他结构）中时保持不变。
```
class ListWrapper:
    def __init__(self, the_list):
        self.the_list = the_list
    def __eq__(self, other):
        return self.the_list == other.the_list
    def __hash__(self):
        l = self.the_list
        result = 98767 - len(l)*555
        for i, el in enumerate(l):
            try:
                result = result + (hash(el) % 9999999) * 1001 + i
            except Exception:
                result = (result % 7777777) + i * 333
        return result
```
注意，哈希计算由于该列表中的一些成员可能是不可哈希的，以及算术溢出的可能性变得复杂。

此外，它必须是这样的情况，如果`o1 == o2`（即 `o1.__eq__(o2)` 为 真），那么`hash(o1) == hash(o2)`（即`o1.__hash__() == o2.__hash__()`），无论该对象是否在字典中。如果不符合这些限制，词典以及其他基于散列的结构将胡作非为。

在ListWrapper的情况下，每当包装对象是在一个字典中，包装列表不能改变，以避免异常。除非你愿意认真考虑这些要求以及不能正确地满足它们的后果，否则不要这样做。考虑自己被警告。

## 为什么list.sort()不返回已排序列表？
在关心性能的情况下，只为了排序而对该列表进行拷贝可能有些浪费。因此，[list.sort()](https://docs.python.org/3/library/stdtypes.html#list.sort)对列表进行就地排序。为了提醒你这个事实，它不会返回已排序列表。这样一来，当你需要一个已排序的副本，并且还需要保持无序版本时，你就不会被骗到意外覆盖一个列表。

如果你想返回一个新的列表，使用内置的[sorted()](https://docs.python.org/3/library/functions.html#sorted)函数来代替。这个函数根据所提供的可迭代对象创建了一个新的列表，对它进行排序，并返回结果。例如，下面是如何遍历有序字典的键：
```
for key in sorted(mydict):
    ... # do whatever with mydict[key]...
```

## Python中如何指定并强制执行接口规范？
由如C++和Java之类的语言所提供的模块接口规范，描述了模块的方法和函数的原型。许多人认为，编译时执行接口规范有助于构建大型项目。

Python 2.6中增加了一个[abc](https://docs.python.org/3/library/abc.html#module-abc)模块，可以让你定义抽象基类（ABC）。然后，您可以使用[isinstance()](https://docs.python.org/3/library/functions.html#isinstance)和[issubclass](https://docs.python.org/3/library/functions.html#issubclass)来检查实例或类是否实现了特定的ABC。[collections.abc](https://docs.python.org/3/library/collections.abc.html#module-collections.abc)模块定义了一组有用的ABC，如 [可迭代](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable)，[容器](https://docs.python.org/3/library/collections.abc.html#collections.abc.Container)和 MutableMapping。

用于Python，许多接口规范的优点可以组件的通过适当的测试规则来获得。还有一个工具，PyChecker，它可以用来寻找由于子类的问题。

一个好的模块测试套件既可以提供一个回归测试，也可以作为一个模块的接口规范和一组例子。许多Python模块可以作为一个脚本来提供一个简单的“自检”。即使使用复杂外部接口的模块也通常可以使用外部接口的微小的“桩”模拟器进行单独测试。[doctest](https://docs.python.org/3/library/doctest.html#module-doctest)和[unittest](https://docs.python.org/3/library/unittest.html#module-unittest)模块或第三方测试框架，可用于构建详尽的测试套件，来测试模块中的每一个代码。

一个合适的测试流程以及拥有接口规范可以帮助使用Python构建大型复杂的应用程序。事实上，它可以更好，因为接口规范不能测试程序的某些性能。例如，`append()`方法添加新元素到一些内部列表的尾部; 接口规范，不能测试你的`append()`的实现将真正正确地做到这一点，但它在测试套件中检查这个属性是微不足道的。

编写测试套件是非常有帮助的，你可能想设计自己的代码，着眼于使其容易测试。一种日益流行的技术，测试导向的开发，要求在编写任何实际的代码之前，首先编写测试套件部分。当然，Python允许你马虎，而完全不用写测试用例。

## 为什么没有goto？
您可以使用异常来提供一个“结构的goto”，即使它是通过函数调用来工作。许多人认为异常可以用来方便地模仿C，Fortran和其他语言的“goto”或“go”的一切合理使用。例如：
```
class label(Exception): pass  # declare a label

try:
     ...
     if condition: raise label()  # goto label
     ...
except label:  # where to goto
     pass
...
```
这不会让你跳进一个循环的中间，但它通常被认为是goto的滥用。请节约使用。

## 为什么原始字符串（r-strings）不以反斜杠结尾？
更确切地说，它们不能用奇数个反斜杠结尾：尾部不成对的反斜杠转义最后引用字符，留下一个未终止字符串。

原始字符串旨在对于那些想要做自己的反斜线转义处理的处理器（主要是正则表达式引擎）减轻输入创建。这样的处理器认为一个不匹配的反斜杠是一个错误，所以原始字符串不允许这样。作为回报，它们允许你传递一个用反斜杠转义的字符串引号字符。当r-字符串用于其预期目的时，这些规则工作良好。

如果你想构造Windows路径名，注意，所有的Windows系统调用也接受斜杠：
```
f = open("/mydir/file.txt")  # works fine!
```
如果你想构造一个DOS命令路径名，如尝试下列例子任意一个：
```
dir = r"\this\is\my\dos\dir" "\\"
dir = r"\this\is\my\dos\dir\ "[:-1]
dir = "\\this\\is\\my\\dos\\dir\\"
```
## 对于属性赋值，Python为什么没有一个“with”语句？
Python有一个'with'语句，它包装一个块的执行，从块的入口和出口调用代码。有些语言有一个结构，它看起来像这样：
```
with obj:
    a = 1               # equivalent to obj.a = 1
    total = total + 1   # obj.total = obj.total + 1
```
在Python中，这样的结构是不明确的。

其他语言，如Object Pascal，Delphi和C ++，使用静态类型，因此它可能知道，在一个明确的方式，哪个成员被分配到。这是静态类型的要点 - 编译器总是在编译时知道每一个变量的范围。

Python使用动态类型。不可能预先知道哪些属性将在运行时被引用。在运行时，成员属性可以被添加或被去除。这使得它不可能从一个简单的读取知道，什么属性被引用：一个本地的，全局的，或成员属性？

例如，下面不完整片段：
```
def foo(a):
    with a:
        print(x)
```
该段假定，“a”必须有一个被称为“x”的成员属性。然而，Python中没有什么会告诉解释器这一点。如果“a”是，假设是一个整数，会发生什么呢？如果有一个名为“x”的全局变量，那么将它被使用于with块内部吗？正如你看到的，Python的动态特性使得这样的选择更加困难。

然而，"with"和类似的语言特性（减少代码量）的主要优势在于，在Python中，它可以简单的通过赋值来实现。代替以下写法：
```
function(args).mydict[index][index].a = 21
function(args).mydict[index][index].b = 42
function(args).mydict[index][index].c = 63
```
这样写：
```
ref = function(args).mydict[index][index]
ref.a = 21
ref.b = 42
ref.c = 63
```
这也具有增加的执行速度的副作用，因为Python在运行时解决了名称绑定，而第二版本只需要执行一次解析。

## 为什么if/while/def/class语句需要冒号？
需要冒号主要是为了增强可读性（实验性ABC语言的结果之一）。试想一下：
```
if a == b
    print(a)
```
与
```
if a == b:
    print(a)
```
请注意，第二个是如何稍微更易于阅读。进一步注意，在本FAQ回答中，冒号是如何设置例子; 它是英语中的一个标准用法。

另一个次要原因是，对于具有语法高亮显示功能的编辑器，冒号使其更容易; 它们可以寻找冒号来决定何时需要增加缩进，而不必对程序文本做一个更详细的解析。

## 为什么Python允许列表和元组结尾处有逗号？
Python允许你在列表，元组和字典的末尾添加逗号：
```
[1, 2, 3,]
('a', 'b', 'c',)
d = {
    "A": [1, 5],
    "B": [6, 7],  # last trailing comma is optional but good style
}
```
允许这种做法，有几个原因。

当你有一个列表，元组，或者字典的文本值，其分布在多个行，很容易添加更多的元素，因为你不必记住添加一个逗号到上一行。也可以对这些行进行重新排序，而不会引发语法错误。

一不留神忽略逗号会导致那些难以诊断的错误。例如：
```
x = [
  "fee",
  "fie"
  "foo",
  "fum"
]
```
该列表看起来有四个元素，但它实际上包含了三个：“fee”, “fiefoo” 和 “fum”。总是加上逗号则会避免这种错误。

允许尾部逗号也使得编程代码生成更加容易。
