# 翻译（转换）

原文：[Translation](https://docs.djangoproject.com/en/1.9/topics/i18n/translation/)
---

## 概述[¶](#overview "Permalink to this headline")

为了使一个Django项目可翻译，你必须将最少数量的钩子添加到您的Python代码和模板中。这些钩子被称为[翻译字符串](https://docs.djangoproject.com/en/1.9/topics/i18n/#term-translation-string)。它们告诉Django：“如果可以将文本翻译成终端用户的语言，那么此文本应该被翻译成终端用户的语言。”你有责任标记出可翻译的字符串; 该系统只能翻译它知道字符串。

然后，Django提供了工具，以提取翻译字符串到一个 [消息文件](https://docs.djangoproject.com/en/1.9/topics/i18n/#term-message-file)中。这个文件是翻译者提供目标语言中翻译字符串的等价物的一个便捷的方式。一旦翻译填补到消息文件中，那么必须对它进行编译。这个过程依赖于GNU的gettext工具集。

一旦完成这点，根据用户的语言首选项，Django会为每一个可用语言动态的翻译Web应用程序。

在默认情况下，Django的国际化钩子是开启的，这意味着，在框架的某些地方中，有一个i18n相关的位的开销。如果你不使用国际化，你应该在你的设置文件中花两秒钟设置 [`USE_I18N = False`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-USE_I18N) 。那么Django会进行一些优化，从而不加载国际化机制。

>注意
>还有一个独立但相关的设置项[USE_L10N](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-USE_L10N)，它控制Django是否应该实现格式化的本地化。见[格式化的本地化](https://docs.djangoproject.com/en/1.9/topics/i18n/formatting/)以获得更详细信息。

>注意
>请确保你的项目已经激活了翻译（最快的方式是检查[MIDDLEWARE_CLASSES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-MIDDLEWARE_CLASSES)是否包括`django.middleware.locale.LocaleMiddleware`）。若无，则见[Django如何发现语言首选项](#Django如何发现语言首选项)。

## 国际化: 在Python代码中[¶](#internationalization-in-python-code "Permalink to this headline")

### 标准翻译[¶](#standard-translation "Permalink to this headline")

通过使用函数[`ugettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext "django.utils.translation.ugettext")指定一个翻译字符串。通常会使用一个较短的别名, `_`, 来导入它，以节省输入。

>注意

    Python标准库`gettext`模块将`_()`安装到全局命名空间中，以作为`gettext()`的别名。在Django中，我们选择不遵循这种做法，出于两个原因：

    1.  对于国际字符集（Unicode）的支持，[`ugettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext "django.utils.translation.ugettext")比`gettext()`更有用。有时，你应该使用[`ugettext_lazy()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext_lazy "django.utils.translation.ugettext_lazy")作为特定文件的默认的翻译方法 。如果全局命名空间中没有`_()`，那么开发者必须考虑哪一个是最合适的翻译函数。
    2.  下划线(`_`)在Python交互式shell及文档测试类的测试中用来表示“前面的结果”。安装全局`_()`函数会造成干扰。显式将`ugettext()`作为`_()`导入可以避免这个问题。

在这个例子中，文本`"Welcome to my site."`被标记为一个翻译字符串：
```python
from django.utils.translation import ugettext as _
from django.http import HttpResponse

def my_view(request):
    output = _("Welcome to my site.")
    return HttpResponse(output)
```
显然，你可以不使用别名来进行编码。下面这个例子与前一个是相同的：
```python
from django.utils.translation import ugettext
from django.http import HttpResponse

def my_view(request):
    output = ugettext("Welcome to my site.")
    return HttpResponse(output)
```
在计算值上进行翻译。下面这个例子与前一个是相同的：
```python
def my_view(request):
    words = ['Welcome', 'to', 'my', 'site.']
    output = _(' '.join(words))
    return HttpResponse(output)
```
在变量上进行翻译。同样，这是同一个例子：
```python
def my_view(request):
    sentence = 'Welcome to my site.'
    output = _(sentence)
    return HttpResponse(output)
```
(对于使用变量或计算值，如前面两个例子，需要说明的是Django的翻译字符串检测功能，[`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages), 不能查找这些字符串。稍后会有更多关于[`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages)的内容。)

你传给`_()`或者`ugettext()`的字符串可以采取占位符，通过Python标准命名字符串插补语法来指定。例如：
```python
def my_view(request, m, d):
    output = _('Today is %(month)s %(day)s.') % {'month': m, 'day': d}
    return HttpResponse(output)
```
这种技术可以让特定的语言翻译重新排列占位符文本。例如，英语翻译可能是`"Today is November 26."`,而西班牙语翻译可能是`"Hoy es 26 de Noviembre."` – 这里，月和日的占位符相互交换。

出于此原因，只要你有一个以上的参数，那么你应该使用命名字符串插值(例如, `%(day)s`)而不是位置插值(例如, `%s` 或者 `%d`)。如果使用位置插值，翻译就不能重新排序占位符文本。

### 翻译注释[¶](#comments-for-translators "Permalink to this headline")

如果你想提供关于一个可翻译字符串的提示，你可以在该字符串前一行添加一个前缀为`Translators`关键字的注释，例如:
```python
def my_view(request):
    # Translators: This message appears on the home page only
    output = ugettext("Welcome to my site.")
```

这个注释稍后将出现在`.po`文件中，而对应的可翻译构造则位于其下，这个注释也应该会被大多数的翻译工具展示出来。

>注意

    只是为了完整性，下面是`.po`文件的对应片段：
    ```python
    #. Translators: This message appears on the home page only
    # path/to/python/file.py:123
    msgid "Welcome to my site."
    msgstr ""
    ```
这也适用于模板。 见[模板中的翻译注释](#translator-comments-in-templates)以了解更多信息。


### 将字符串标记为no-op[¶](#marking-strings-as-no-op "Permalink to this headline")

使用函数[`django.utils.translation.ugettext_noop()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext_noop "django.utils.translation.ugettext_noop") 将一个字符串标记为一个翻译字符串而实际上不翻译它。该字符串稍后会根据一个变量进行翻译。

如果你有应以源语言存储的常量字符串，那么使用它，因为它们在系统或用户间被转化 – 例如数据库中的字符串 – 当应该在最后的时间点进行翻译，例如当该字符串被展示给用户时。

### 多元化[¶](#pluralization "Permalink to this headline")

使用函数[`django.utils.translation.ungettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ungettext "django.utils.translation.ungettext")来指定复数信息。

`ungettext`接收三个参数：单数翻译字符串，复数翻译字符串和对象的数量。

This function is useful when you need your Django application to be localizable
to languages where the number and complexity of [复数形式](https://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms) is
greater than the two forms used in English (‘object’ for the singular and
‘objects’ for all the cases where `count` is different from one, irrespective
of its value.)

例如：
```python
from django.utils.translation import ungettext
from django.http import HttpResponse

def hello_world(request, count):
    page = ungettext(
        'there is %(count)d object',
        'there are %(count)d objects',
    count) % {
        'count': count,
    }
    return HttpResponse(page)
```
在这个例子中，对象的数量作为`count`变量传给翻译语言。

需要注意的是，多元化是复杂的，并且不同的语言工作不同。将`count`与1进行对比并不总是正确的规则。下面这个代码看起来复杂，但对某些语言来说，将产生不正确的结果：
```python
from django.utils.translation import ungettext
from myapp.models import Report

count = Report.objects.count()
if count == 1:
    name = Report._meta.verbose_name
else:
    name = Report._meta.verbose_name_plural

text = ungettext(
    'There is %(count)d %(name)s available.',
    'There are %(count)d %(name)s available.',
    count
) % {
    'count': count,
    'name': name
}
```
不要试图实现自己的单数-或-复数逻辑，它可能是不正确的。在这样的情况下，考虑类似以下内容：
```python
text = ungettext(
    'There is %(count)d %(name)s object available.',
    'There are %(count)d %(name)s objects available.',
    count
) % {
    'count': count,
    'name': Report._meta.verbose_name,
}
```

>注意

    使用`ungettext()`时,确保对每一个包含在文本中的推测变量使用单一的名字。在上面的例子中，请注意我们如何在两个翻译字符串中使用Python变量`name`。这个例子中，除了在上面所述的一些语言中不正确外，也将导致失败：
    ```python
    text = ungettext(
        'There is %(count)d %(name)s available.',
        'There are %(count)d %(plural_name)s available.',
        count
    ) % {
        'count': Report.objects.count(),
        'name': Report._meta.verbose_name,
        'plural_name': Report._meta.verbose_name_plural
    }
    ```
    在运行[`django-admin
    compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages)时，你会得到一个错误:

    `a format specification for argument 'name', as in 'msgstr[0]', doesn't exist in 'msgid'`

>注意

    复数形式和po文件

    Django不支持在po文件中自定义复数方程。在合并所有翻译目录时，只有主要的Django po文件(在`django/conf/locale/<lang_code>/LC_MESSAGES/django.po`中)的复数形式会被考虑。其他所有的po文件中的复数形式将被忽略。因此，你不应该在项目或应用po文件中使用不同的复数方程。

### 上下文标记[¶](#contextual-markers "Permalink to this headline")

有时候，词语会有多种含义，例如英语中的`"May"`指的是一个月份名称和一个动词。要让翻译器在不同的上下文中正确的翻译这些词语，可以使用[`django.utils.translation.pgettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.pgettext "django.utils.translation.pgettext")函数，或者如果字符串需要复数，则使用[`django.utils.translation.npgettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.npgettext "django.utils.translation.npgettext")函数。这两个函数都接受一个上下文字符串作为第一个变量。

在得到的`.po`文件中，若相同的字符串有不同的上下文标记，则该串将出现多次 (上下文将出现在`msgctxt`行), 从而允许翻译器为它们的每一个都提供一个不同的翻译。

例如：
```python
from django.utils.translation import pgettext

month = pgettext("month name", "May")
```
或者：
```python
from django.db import models
from django.utils.translation import pgettext_lazy

class MyThing(models.Model):
    name = models.CharField(help_text=pgettext_lazy(
        'help text for MyThing model', 'This is the help text'))
```
在`.po`文件中将显示为：
```python
msgctxt "month name"
msgid "May"
msgstr ""
```
[`trans`](#std:templatetag-trans)和[`blocktrans`](#std:templatetag-blocktrans)模板标签也支持上下文标记。


### 惰性翻译[¶](#lazy-translation "Permalink to this headline")

使用[`django.utils.translation`](#module-django.utils.translation "django.utils.translation")中翻译函数的惰性版本(lazy version) (easily recognizable by the 从它们名字中的`lazy`后缀可以很容易辨认)来懒惰地翻译字符串 - 当访问值而不是调用值时。

这些函数储存一个字符串的惰性引用 - 而不是实际的翻译。当该字符串被用于一个字符串上下文中时，例如在模板渲染中，翻译本身将会被完成。

当这些函数的调用位于在模块加载时间执行的代码路径时，这是必不可少的。

当定义模块，表单和模型形式时，这是极易发生的，因为Django实现这些，使得它们的域实际上是类级属性。因此，在下列情况下，请务必使用惰性翻译：


#### Model域和关系`verbose_name`和`help_text`选项值[¶](#model-fields-and-relationships-verbose-name-and-help-text-option-values "Permalink to this headline")

例如，要翻译下面模型中的name域的帮助文本，请执行以下操作：
```python
from django.db import models
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    name = models.CharField(help_text=_('This is the help text'))
```
You can mark names of [`ForeignKey`](https://docs.djangoproject.com/en/1.9/ref/models/fields/#django.db.models.ForeignKey "django.db.models.ForeignKey"),
[`ManyToManyField`](https://docs.djangoproject.com/en/1.9/ref/models/fields/#django.db.models.ManyToManyField "django.db.models.ManyToManyField") or
[`OneToOneField`](https://docs.djangoproject.com/en/1.9/ref/models/fields/#django.db.models.OneToOneField "django.db.models.OneToOneField") relationship as translatable by using
their [`verbose_name`](https://docs.djangoproject.com/en/1.9/ref/models/options/#django.db.models.Options.verbose_name "django.db.models.Options.verbose_name") options:
```python
class MyThing(models.Model):
    kind = models.ForeignKey(
        ThingKind,
        on_delete=models.CASCADE,
        related_name='kinds',
        verbose_name=_('kind'),
    )
```
Just like you would do in [`verbose_name`](https://docs.djangoproject.com/en/1.9/ref/models/options/#django.db.models.Options.verbose_name "django.db.models.Options.verbose_name") you
should provide a lowercase verbose name text for the relation as Django will
automatically titlecase it when required.


#### Model详细名称值[¶](#model-verbose-names-values "Permalink to this headline")

建议始终提供明确的[`verbose_name`](https://docs.djangoproject.com/en/1.9/ref/models/options/#django.db.models.Options.verbose_name "django.db.models.Options.verbose_name")和[`verbose_name_plural`](https://docs.djangoproject.com/en/1.9/ref/models/options/#django.db.models.Options.verbose_name_plural "django.db.models.Options.verbose_name_plural")选项，而不是依靠后备英语中心以及Django通过查找模型类名执行来决定的有些天真的详细名称：
```python
from django.db import models
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    name = models.CharField(_('name'), help_text=_('This is the help text'))

    class Meta:
        verbose_name = _('my thing')
        verbose_name_plural = _('my things')
```

#### Model方法`short_description`属性值[¶](#model-methods-short-description-attribute-values "Permalink to this headline")

对于模型方法，你可以使用`short_description`属性来提供到Django和admin站点的翻译：
```python
from django.db import models
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    kind = models.ForeignKey(
        ThingKind,
        on_delete=models.CASCADE,
        related_name='kinds',
        verbose_name=_('kind'),
    )

    def is_mouse(self):
        return self.kind.type == MOUSE_TYPE
    is_mouse.short_description = _('Is it a mouse?')
```

### Working with lazy translation objects[¶](#working-with-lazy-translation-objects "Permalink to this headline")

The result of a `ugettext_lazy()` call can be used wherever you would use a
unicode string (an object with type `unicode`) in Python. If you try to use
it where a bytestring (a `str` object) is expected, things will not work as
expected, since a `ugettext_lazy()` object doesn’t know how to convert
itself to a bytestring. You can’t use a unicode string inside a bytestring,
either, so this is consistent with normal Python behavior. For example:
```python
# This is fine: putting a unicode proxy into a unicode string.
"Hello %s" % ugettext_lazy("people")

# This will not work, since you cannot insert a unicode object
# into a bytestring (nor can you insert our unicode proxy there)
b"Hello %s" % ugettext_lazy("people")
```
If you ever see output that looks like `"hello
<django.utils.functional...>;"`, you have tried to insert the result of
`ugettext_lazy()` into a bytestring. That’s a bug in your code.
```python
If you don’t like the long `ugettext_lazy` name, you can just alias it as
`_` (underscore), like so:

from django.db import models
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    name = models.CharField(help_text=_('This is the help text'))
```
Using `ugettext_lazy()` and `ungettext_lazy()` to mark strings in models
and utility functions is a common operation. When you’re working with these
objects elsewhere in your code, you should ensure that you don’t accidentally
convert them to strings, because they should be converted as late as possible
(so that the correct locale is in effect). This necessitates the use of the
helper function described next.

#### 惰性翻译和复数[¶](#lazy-translations-and-plural "Permalink to this headline")

当为一个复数字符串(`[u]n[p]gettext_lazy`)使用惰性翻译时，在该字符串定义的时候，一般你不会知道`number`参数的值。因此，你有权传递一个关键字名称，而不是一个整数来作为`number`参数的值。然后，在字符串插值时，将会在该键的字典中查找`number`。这里有一个例子：
```python
from django import forms
from django.utils.translation import ungettext_lazy

class MyForm(forms.Form):
    error_message = ungettext_lazy("You only provided %(num)d argument",
        "You only provided %(num)d arguments", 'num')

    def clean(self):
        # ...
        if error:
            raise forms.ValidationError(self.error_message % {'num': number})
```

若字符串包含一个未命名的占位符，你可以直接插入`number`参数：
```python
class MyForm(forms.Form):
    error_message = ungettext_lazy("You provided %d argument",
        "You provided %d arguments")

    def clean(self):
        # ...
        if error:
            raise forms.ValidationError(self.error_message % number)
```

#### 字符串连接: string_concat()[¶](#joining-strings-string-concat "Permalink to this headline")

标准的Python字符串连接(`''.join([...])`)在包含惰性翻译的对象的列表上无效。相反，你可以使用[`django.utils.translation.string_concat()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.string_concat "django.utils.translation.string_concat"), 它创建了一个惰性对象，这个对象会连接它的内容，并只有在结果被包含在一个字符串中时将其转换成字符串。例如：
```python
from django.utils.translation import string_concat
from django.utils.translation import ugettext_lazy
...
name = ugettext_lazy('John Lennon')
instrument = ugettext_lazy('guitar')
result = string_concat(name, ': ', instrument)
```
在这种情况下，`result`中的惰性翻译将只有在`result`自身被使用在一个字符串中的时候（通常在模板渲染的时候），才被转换成一个字符串。


#### 在延迟翻译中，惰性的其他用途[¶](#other-uses-of-lazy-in-delayed-translations "Permalink to this headline")

For any other case where you would like to delay the translation, but have to
pass the translatable string as argument to another function, you can wrap
this function inside a lazy call yourself. For example:
```python
from django.utils import six  # Python 3 compatibility
from django.utils.functional import lazy
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

mark_safe_lazy = lazy(mark_safe, six.text_type)
```

接着：

`lazy_string = mark_safe_lazy(_("<p>My <strong>string!</strong></p>"))`

### Localized names of languages[¶](#localized-names-of-languages "Permalink to this headline")

`get_language_info`()[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/utils/translation/#get_language_info)[¶](#django.utils.translation.get_language_info "Permalink to this definition")

The `get_language_info()` function provides detailed information about
languages:
```python
>>> from django.utils.translation import get_language_info
>>> li = get_language_info('de')
>>> print(li['name'], li['name_local'], li['bidi'])
German Deutsch False
```

The `name` and `name_local` attributes of the dictionary contain the name of
the language in English and in the language itself, respectively.  The `bidi`
attribute is True only for bi-directional languages.

The source of the language information is the `django.conf.locale` module.
Similar access to this information is available for template code. See below.


## 国际化: 在模板代码中[¶](#internationalization-in-template-code "Permalink to this headline")

[Django模板](https://docs.djangoproject.com/en/1.9/ref/templates/language/)中的翻译使用两个模板标签和一个稍微与Python代码不同的语法。为了让您的模板访问这些标签，将`{% load i18n %}`放在模板的顶部。如同所有的模板标签，需要在所有使用翻译的模板中加载这个标签，即使是那些从其他已经加载过`i18n`标签的模板中扩展出来的模板。

### `trans`模板标签[¶](#trans-template-tag "Permalink to this headline")

`{% trans %}`模板标签翻译一个常量字符串(用单引号或双引号括起来)或者一个变量内容：
```python
<title>{% trans "This is the title." %}</title>
<title>{% trans myvar %}</title>
```

If the 若使用`noop`选项，那么仍然会发生变量查找，但会跳过翻译。这在“删空”内容在未来将需要翻译时是非常有用的：

`<title>{% trans "myvar" noop %}</title>`

在内部，在线翻译使用一个[`ugettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext "django.utils.translation.ugettext")调用。

万一一个模板变量(上面的`myvar`)被传递给该标签，那么该标签将首先在运行时间将该变量解析成一个字符串，然后在消息目录下查找该字符串。

不能在`{% trans
%}`中的字符串中混淆使用模板变量。如果翻译需要带变量（占位符）的字符串，使用[`{% blocktrans %}`](#std:templatetag-blocktrans)代替。

若你想获取一个翻译字符串而不把它展示出来，可以使用下面的语法：
```python
{% trans "This is the title" as the_title %}

<title>{{ the_title }}</title>
<meta name="description" content="{{ the_title }}">
```

在实际应用中，可以这样以获得一个字符串，你可以在模板中多处使用，或者可以将此输出作为一个参数，以用于其他模板标签或者过滤器：
```python
{% trans "starting point" as start %}
{% trans "end point" as end %}
{% trans "La Grande Boucle" as race %}

<h1>
  <a href="/" title="{% blocktrans %}Back to '{{ race }}' homepage{% endblocktrans %}">{{ race }}</a>
</h1>
<p>
{% for stage in tour_stages %}
    {% cycle start end %}: {{ stage }}{% if forloop.counter|divisibleby:2 %}<br />{% else %}, {% endif %}
{% endfor %}
</p>
```

`{% trans %}`也支持使用`context`关键字的[上下文标记](#contextual-markers)：

```{% trans "May" context "month name" %}```

### `blocktrans`模板标签[¶](#blocktrans-template-tag "Permalink to this headline")

与[`trans`](#std:templatetag-trans)标签相比，`blocktrans`标签允许你通过利用占位符，标记复杂的句子（由文字和用于翻译的变量内容组成）：

`{%blocktrans%}This string will have {{value}} inside.{%endblocktrans%}`

要翻译一个模板表达式 - 比如，访问对象属性或者使用模板过滤器 - 你需要绑定该表达式到一个局部变量以便于在翻译块中使用。例如：
```python
{% blocktrans with amount=article.price %}
That will cost $ {{ amount }}.
{% endblocktrans %}

{% blocktrans with myvar=value|filter %}
This will have {{ myvar }} inside.
{% endblocktrans %}
```
You can use multiple expressions inside a single `blocktrans` tag:
```python
{% blocktrans with book_t=book|title author_t=author|title %}
This is {{ book_t }} by {{ author_t }}
{% endblocktrans %}
```

>Note

>The previous more verbose format is still supported:
`{% blocktrans with book|title as book_t and author|title as author_t %}`


Other block tags (for example `{% for %}` or `{% if %}`) are not allowed
inside a `blocktrans` tag.

If resolving one of the block arguments fails, blocktrans will fall back to
the default language by deactivating the currently active language
temporarily with the [`deactivate_all()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.deactivate_all "django.utils.translation.deactivate_all")
function.

This tag also provides for pluralization. To use it:

*   Designate and bind a counter value with the name `count`. This value will
be the one used to select the right plural form.
*   Specify both the singular and plural forms separating them with the
`{% plural %}` tag within the `{% blocktrans %}` and
`{% endblocktrans %}` tags.

An example:
```python
{% blocktrans count counter=list|length %}
There is only one {{ name }} object.
{% plural %}
There are {{ counter }} {{ name }} objects.
{% endblocktrans %}
```

一个更复杂的例子：
```python
{% blocktrans with amount=article.price count years=i.length %}
That will cost $ {{ amount }} per year.
{% plural %}
That will cost $ {{ amount }} per {{ years }} years.
{% endblocktrans %}
```

When you use both the pluralization feature and bind values to local variables
in addition to the counter value, keep in mind that the `blocktrans`
construct is internally converted to an `ungettext` call. This means the
same [notes regarding ungettext variables](#pluralization-var-notes)
apply.

Reverse URL lookups cannot be carried out within the `blocktrans` and should
be retrieved (and stored) beforehand:
```python
{% url 'path.to.view' arg arg2 as the_url %}
{% blocktrans %}
This is a URL: {{ the_url }}
{% endblocktrans %}
```

If you’d like to retrieve a translated string without displaying it, you can
use the following syntax:
```python
{% blocktrans asvar the_title %}The title is {{ title }}.{% endblocktrans %}
<title>{{ the_title }}</title>
<meta name="description" content="{{ the_title }}">
```

In practice you’ll use this to get a string you can use in multiple places in a
template or so you can use the output as an argument for other template tags or
filters.


The `asvar` syntax was added.


`{% blocktrans %}` also supports [<span>contextual
markers](#contextual-markers) using the `context` keyword:

`{% blocktrans with name=user.username context "greeting" %}Hi {{ name }}{% endblocktrans %}`

Another feature `{% blocktrans %}` supports is the `trimmed` option. This
option will remove newline characters from the beginning and the end of the
content of the `{% blocktrans %}` tag, replace any whitespace at the beginning
and end of a line and merge all lines into one using a space character to
separate them. This is quite useful for indenting the content of a `{%
blocktrans %}` tag without having the indentation characters end up in the
corresponding entry in the PO file, which makes the translation process easier.

For instance, the following `{% blocktrans %}` tag:
```python
{% blocktrans trimmed %}
  First sentence.
  Second paragraph.
{% endblocktrans %}
```

will result in the entry `"First sentence. Second paragraph."` in the PO file,
compared to `"\n&nbsp; First sentence.\n&nbsp; Second sentence.\n"`, if the `trimmed`
option had not been specified.


### String literals passed to tags and filters[¶](#string-literals-passed-to-tags-and-filters "Permalink to this headline")

You can translate string literals passed as arguments to tags and filters
by using the familiar `_()` syntax:

`{% some_tag _("Page not found") value|yesno:_("yes,no") %}`

In this case, both the tag and the filter will see the translated string,
so they don’t need to be aware of translations.


>Note

>In this example, the translation infrastructure will be passed the string
`"yes,no"`, not the individual strings `"yes"` and `"no"`. The
translated string will need to contain the comma so that the filter
parsing code knows how to split up the arguments. For example, a German
translator might translate the string `"yes,no"` as `"ja,nein"`
(keeping the comma intact).


### Comments for translators in templates[¶](#comments-for-translators-in-templates "Permalink to this headline")

Just like with [<span>Python code](#translator-comments), these notes for
translators can be specified using comments, either with the [`comment`](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#std:templatetag-comment)
tag:
```python
{% comment %}Translators: View verb{% endcomment %}
{% trans "View" %}

{% comment %}Translators: Short intro blurb{% endcomment %}
<p>{% blocktrans %}A multiline translatable
literal.{% endblocktrans %}</p>
```

or with the `{#` ... `#}` [<span>one-line comment constructs](https://docs.djangoproject.com/en/1.9/ref/templates/language/#template-comments):
```python
{# Translators: Label of a button that triggers search #}
<button type="submit">{% trans "Go" %}</button>

{# Translators: This is a text of the base template #}
{% blocktrans %}Ambiguous translatable block of text{% endblocktrans %}
```

>注意：

>为了完整性，下面是所得的`.po`文件的相应片段：
```python
#. Translators: View verb
# path/to/template/file.html:10
msgid "View"
msgstr ""

#. Translators: Short intro blurb
# path/to/template/file.html:13
msgid ""
"A multiline translatable"
"literal."
msgstr ""

# ...

#. Translators: Label of a button that triggers search
# path/to/template/file.html:100
msgid "Go"
msgstr ""

#. Translators: This is a text of the base template
# path/to/template/file.html:103
msgid "Ambiguous translatable block of text"
msgstr ""
```

### 在模板中切换语言[¶](#switching-language-in-templates "Permalink to this headline")

如果你想要在一个模板中选择一个语言，可以用使用`language`模板标签：
```python
{% load i18n %}

{% get_current_language as LANGUAGE_CODE %}
<!-- Current language: {{ LANGUAGE_CODE }} -->
<p>{% trans "Welcome to our page" %}</p>

{% language 'en' %}
    {% get_current_language as LANGUAGE_CODE %}
    <!-- Current language: {{ LANGUAGE_CODE }} -->
    <p>{% trans "Welcome to our page" %}</p>
{% endlanguage %}
```

当“Welcome to our page”的第一次出现使用当前语言时，其第二次出现将总是英语。


### Other tags[¶](#other-tags "Permalink to this headline")

These tags also require a `{% load i18n %}`.

#### `get_available_languages`[¶](#get-available-languages "Permalink to this headline")

`{% get_available_languages as LANGUAGES %}` returns a list of tuples in
which the first element is the [<span class="xref std std-term">language code](../#term-language-code) and the second is the
language name (translated into the currently active locale).


#### `get_current_language`[¶](#get-current-language "Permalink to this headline")

`{% get_current_language as LANGUAGE_CODE %}` returns the current user’s
preferred language as a string. Example: `en-us`. See
[<span>How Django discovers language preference](#how-django-discovers-language-preference).


#### `get_current_language_bidi`[¶](#get-current-language-bidi "Permalink to this headline")

`{% get_current_language_bidi as LANGUAGE_BIDI %}` returns the current
locale’s direction. If `True`, it’s a right-to-left language, e.g. Hebrew,
Arabic. If `False` it’s a left-to-right language, e.g. English, French,
German, etc.

If you enable the `django.template.context_processors.i18n` context processor
then each `RequestContext` will have access to `LANGUAGES`,
`LANGUAGE_CODE`, and `LANGUAGE_BIDI` as defined above.

Changed in Django 1.8:

The `i18n` context processor is not enabled by default for new projects.


#### `get_language_info`[¶](#get-language-info "Permalink to this headline")

You can also retrieve information about any of the available languages using
provided template tags and filters. To get information about a single language,
use the `{% get_language_info %}` tag:
```python
{% get_language_info for LANGUAGE_CODE as lang %}
{% get_language_info for "pl" as lang %}
```

You can then access the information:
```python
Language code: {{ lang.code }}<br />
Name of language: {{ lang.name_local }}<br />
Name in English: {{ lang.name }}<br />
Bi-directional: {{ lang.bidi }}
Name in the active language: {{ lang.name_translated }}
```

New in Django 1.9:

The `name_translated` attribute was added.


#### `get_language_info_list`[¶](#get-language-info-list "Permalink to this headline")

You can also use the `{% get_language_info_list %}` template tag to retrieve
information for a list of languages (e.g. active languages as specified in
[`LANGUAGES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGES)). See [<span>the section about the set_language redirect
view](#set-language-redirect-view) for an example of how to display a language
selector using `{% get_language_info_list %}`.

In addition to [`LANGUAGES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGES) style list of tuples,
`{% get_language_info_list %}` supports simple lists of language codes.
If you do this in your view:
```python
context = {'available_languages': ['en', 'es', 'fr']}
return render(request, 'mytemplate.html', context)
```

you can iterate over those languages in the template:
```python
{% get_language_info_list for available_languages as langs %}
{% for lang in langs %} ... {% endfor %}
```

#### Template filters[¶](#template-filters "Permalink to this headline")

There are also simple filters available for convenience:

*   `{{ LANGUAGE_CODE|language_name }}` (“German”)
*   `{{ LANGUAGE_CODE|language_name_local }}` (“Deutsch”)
*   `{{ LANGUAGE_CODE|language_bidi }}` (False)
*   `{{ LANGUAGE_CODE|language_name_translated }}` (“německy”, when active language is Czech)

New in Django 1.9:

The `language_name_translated` filter was added.

## Internationalization: in JavaScript code[¶](#internationalization-in-javascript-code "Permalink to this headline")

Adding translations to JavaScript poses some problems:

*   JavaScript code doesn’t have access to a `gettext` implementation.
*   JavaScript code doesn’t have access to `.po` or `.mo` files; they need to
be delivered by the server.
*   The translation catalogs for JavaScript should be kept as small as
possible.

Django provides an integrated solution for these problems: It passes the
translations into JavaScript, so you can call `gettext`, etc., from within
JavaScript.


### `javascript_catalog`视图[¶](#module-django.views.i18n "Permalink to this headline")
```python
from django.views.i18n import javascript_catalog

js_info_dict = {
    'packages': ('your.app.package',),
}

urlpatterns = [
    url(r'^jsi18n/$', javascript_catalog, js_info_dict),
]
```

The main solution to these problems is the
[`django.views.i18n.javascript_catalog()`](#django.views.i18n.javascript_catalog "django.views.i18n.javascript_catalog") view, which sends out a JavaScript
code library with functions that mimic the `gettext` interface, plus an array
of translation strings. Those translation strings are taken from applications or
Django core, according to what you specify in either the `info_dict` or the
URL. Paths listed in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) are also included.

You hook it up like this:
```python
from django.views.i18n import javascript_catalog

js_info_dict = {
    'packages': ('your.app.package',),
}

urlpatterns = [
    url(r'^jsi18n/$', javascript_catalog, js_info_dict),
]
```

Each string in `packages` should be in Python dotted-package syntax (the
same format as the strings in [`INSTALLED_APPS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-INSTALLED_APPS)) and should refer to a
package that contains a `locale` directory. If you specify multiple packages,
all those catalogs are merged into one catalog. This is useful if you have
JavaScript that uses strings from different applications.

The precedence of translations is such that the packages appearing later in the
`packages` argument have higher precedence than the ones appearing at the
beginning, this is important in the case of clashing translations for the same
literal.

By default, the view uses the `djangojs` gettext domain. This can be
changed by altering the `domain` argument.

You can make the view dynamic by putting the packages into the URL pattern:
```python
urlpatterns = [
    url(r'^jsi18n/(?P<packages>\S+?)/$', javascript_catalog),
]
```

With this, you specify the packages as a list of package names delimited by ‘+’
signs in the URL. This is especially useful if your pages use code from
different apps and this changes often and you don’t want to pull in one big
catalog file. As a security measure, these values can only be either
`django.conf` or any package from the [`INSTALLED_APPS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-INSTALLED_APPS) setting.

You can also split the catalogs in multiple URLs and load them as you need in
your sites:
```python
js_info_dict_app = {
    'packages': ('your.app.package',),
}

js_info_dict_other_app = {
    'packages': ('your.other.app.package',),
}

urlpatterns = [
    url(r'^jsi18n/app/$', javascript_catalog, js_info_dict_app),
    url(r'^jsi18n/other_app/$', javascript_catalog, js_info_dict_other_app),
]
```

If you use more than one `javascript_catalog` on a site and some of them
define the same strings, the strings in the catalog that was loaded last take
precedence.

Changed in Django 1.9:

Before Django 1.9, the catalogs completely overwrote each other and you
could only use one at a time.



The JavaScript translations found in the paths listed in the
[`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) setting are also always included. To keep consistency
with the translations lookup order algorithm used for Python and templates, the
directories listed in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) have the highest precedence with
the ones appearing first having higher precedence than the ones appearing
later.


### Using the JavaScript translation catalog[¶](#using-the-javascript-translation-catalog "Permalink to this headline")

To use the catalog, just pull in the dynamically generated script like this:
```html
<script type="text/javascript" src="{% url 'django.views.i18n.javascript_catalog' %}"></script>
```

This uses reverse URL lookup to find the URL of the JavaScript catalog view.
When the catalog is loaded, your JavaScript code can use the following methods:

*   `gettext`
*   `ngettext`
*   `interpolate`
*   `get_format`
*   `gettext_noop`
*   `pgettext`
*   `npgettext`
*   `pluralidx`

#### `gettext`[¶](#gettext "Permalink to this headline")

`gettext`函数与Python代码中标准的`gettext`接口行为相似：

`document.write(gettext('this is to be translated'));`


#### `ngettext`[¶](#ngettext "Permalink to this headline")

`ngettext`函数提供了一个接口，用来复数化单词和短语：
```js
var object_count = 1 // or 0, or 2, or 3, ...
s = ngettext('literal for the singular case',
        'literal for the plural case', object_count);
```

#### `interpolate`[¶](#interpolate "Permalink to this headline")

The `interpolate` function supports dynamically populating a format string.
The interpolation syntax is borrowed from Python, so the `interpolate`
function supports both positional and named interpolation:

*   Positional interpolation: `obj` contains a JavaScript Array object
whose elements values are then sequentially interpolated in their
corresponding `fmt` placeholders in the same order they appear.
For example:
```python
    fmts = ngettext('There is %s object. Remaining: %s',
            'There are %s objects. Remaining: %s', 11);
    s = interpolate(fmts, [11, 20]);
    // s is 'There are 11 objects. Remaining: 20'
    ```

*   Named interpolation: This mode is selected by passing the optional
boolean `named` parameter as `true`. `obj` contains a JavaScript
object or associative array. For example:
```python
   d = {
        count: 10,
        total: 50
    };

    fmts = ngettext('Total: %(total)s, there is %(count)s object',
    'there are %(count)s of a total of %(total)s objects', d.count);
    s = interpolate(fmts, d, true);
```

You shouldn’t go over the top with string interpolation, though: this is still
JavaScript, so the code has to make repeated regular-expression substitutions.
This isn’t as fast as string interpolation in Python, so keep it to those
cases where you really need it (for example, in conjunction with `ngettext`
to produce proper pluralizations).


#### `get_format`[¶](#get-format "Permalink to this headline")

The `get_format` function has access to the configured i18n formatting
settings and can retrieve the format string for a given setting name:
```python
document.write(get_format('DATE_FORMAT'));
// 'N j, Y'
```

It has access to the following settings:

*   [`DATE_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATE_FORMAT)
*   [`DATE_INPUT_FORMATS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATE_INPUT_FORMATS)
*   [`DATETIME_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATETIME_FORMAT)
*   [`DATETIME_INPUT_FORMATS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DATETIME_INPUT_FORMATS)
*   [`DECIMAL_SEPARATOR`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DECIMAL_SEPARATOR)
*   [`FIRST_DAY_OF_WEEK`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-FIRST_DAY_OF_WEEK)
*   [`MONTH_DAY_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-MONTH_DAY_FORMAT)
*   [`NUMBER_GROUPING`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-NUMBER_GROUPING)
*   [`SHORT_DATE_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-SHORT_DATE_FORMAT)
*   [`SHORT_DATETIME_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-SHORT_DATETIME_FORMAT)
*   [`THOUSAND_SEPARATOR`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-THOUSAND_SEPARATOR)
*   [`TIME_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TIME_FORMAT)
*   [`TIME_INPUT_FORMATS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TIME_INPUT_FORMATS)
*   [`YEAR_MONTH_FORMAT`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-YEAR_MONTH_FORMAT)

This is useful for maintaining formatting consistency with the Python-rendered
values.


#### `gettext_noop`[¶](#gettext-noop "Permalink to this headline")

This emulates the `gettext` function but does nothing, returning whatever
is passed to it:

`document.write(gettext_noop('this will not be translated'));`

This is useful for stubbing out portions of the code that will need translation
in the future.

#### `pgettext`[¶](#pgettext "Permalink to this headline")

The `pgettext` function behaves like the Python variant
([`pgettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.pgettext "django.utils.translation.pgettext")), providing a contextually
translated word:

`document.write(pgettext('month name', 'May'));`

#### `npgettext`[¶](#npgettext "Permalink to this headline")

The `npgettext` function also behaves like the Python variant
([`npgettext()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.npgettext "django.utils.translation.npgettext")), providing a **pluralized**
contextually translated word:
```python
document.write(npgettext('group', 'party', 1));
// party
document.write(npgettext('group', 'party', 2));
// parties
```

#### `pluralidx`[¶](#pluralidx "Permalink to this headline")

The `pluralidx` function works in a similar way to the [`pluralize`](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#std:templatefilter-pluralize)
template filter, determining if a given `count` should use a plural form of
a word or not:
```python
document.write(pluralidx(0));
// true
document.write(pluralidx(1));
// false
document.write(pluralidx(2));
// true
```

In the simplest case, if no custom pluralization is needed, this returns
`false` for the integer `1` and `true` for all other numbers.

However, pluralization is not this simple in all languages. If the language does
not support pluralization, an empty value is provided.

Additionally, if there are complex rules around pluralization, the catalog view
will render a conditional expression. This will evaluate to either a `true`
(should pluralize) or `false` (should **not** pluralize) value.

### The `json_catalog` view[¶](#the-json-catalog-view "Permalink to this headline")

<div class="versionadded">
<span class="title">New in Django 1.9. </div>
<dl class="function">
<dt id="django.views.i18n.json_catalog">
`json_catalog`(_request_, _domain='djangojs'_, _packages=None_)[<span class="viewcode-link">[source]](https://docs.djangoproject.com/en/1.9/_modules/django/views/i18n/#json_catalog)[¶](#django.views.i18n.json_catalog "Permalink to this definition")</dt>
<dd></dd></dl>

In order to use another client-side library to handle translations, you may
want to take advantage of the `json_catalog()` view. It’s similar to
[`javascript_catalog()`](#django.views.i18n.javascript_catalog "django.views.i18n.javascript_catalog") but returns a JSON response.

The JSON object contains i18n formatting settings (those available for
[get_format](#get-format)), a plural rule (as a `plural` part of a GNU gettext
`Plural-Forms` expression), and translation strings. The translation strings
are taken from applications or Django’s own translations, according to what is
specified either via `urlpatterns` arguments or as request parameters. Paths
listed in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) are also included.

The view is hooked up to your application and configured in the same fashion as
[`javascript_catalog()`](#django.views.i18n.javascript_catalog "django.views.i18n.javascript_catalog") (namely, the `domain` and
`packages` arguments behave identically):

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">from <span class="nx">django<span class="p">.<span class="nx">views<span class="p">.<span class="nx">i18n <span class="kr">import <span class="nx">json_catalog

<span class="nx">js_info_dict <span class="o">= <span class="p">{
    <span class="s1">'packages'<span class="o">: <span class="p">(<span class="s1">'your.app.package'<span class="p">,),
<span class="p">}

<span class="nx">urlpatterns <span class="o">= <span class="p">[
    <span class="nx">url<span class="p">(<span class="nx">r<span class="s1">'^jsoni18n/$'<span class="p">, <span class="nx">json_catalog<span class="p">, <span class="nx">js_info_dict<span class="p">),
<span class="p">]
</pre></div>
</div>

The response format is as follows:

<div class="highlight-json"><div class="highlight"><pre>{
    "catalog": {
        # Translations catalog
    },
    "formats": {
        # Language formats for date, time, etc.
    },
    "plural": "..."  # Expression for plural forms, or null.
}
</pre></div>
</div>

### Note on performance[¶](#note-on-performance "Permalink to this headline")

The [`javascript_catalog()`](#django.views.i18n.javascript_catalog "django.views.i18n.javascript_catalog") view generates the catalog
from `.mo` files on every request. Since its output is constant — at least
for a given version of a site — it’s a good candidate for caching.

Server-side caching will reduce CPU load. It’s easily implemented with the
[`cache_page()`](../../cache/#django.views.decorators.cache.cache_page "django.views.decorators.cache.cache_page") decorator. To trigger cache
invalidation when your translations change, provide a version-dependent key
prefix, as shown in the example below, or map the view at a version-dependent
URL.

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.views.decorators.cache <span class="kn">import <span class="n">cache_page
<span class="kn">from <span class="nn">django.views.i18n <span class="kn">import <span class="n">javascript_catalog

<span class="c"># The value returned by get_version() must change when translations change.
<span class="nd">@cache_page<span class="p">(<span class="mi">86400<span class="p">, <span class="n">key_prefix<span class="o">=<span class="s">'js18n-<span class="si">%s<span class="s">' <span class="o">% <span class="n">get_version<span class="p">())
<span class="k">def <span class="nf">cached_javascript_catalog<span class="p">(<span class="n">request<span class="p">, <span class="n">domain<span class="o">=<span class="s">'djangojs'<span class="p">, <span class="n">packages<span class="o">=<span class="bp">None<span class="p">):
    <span class="k">return <span class="n">javascript_catalog<span class="p">(<span class="n">request<span class="p">, <span class="n">domain<span class="p">, <span class="n">packages<span class="p">)
</pre></div>
</div>

Client-side caching will save bandwidth and make your site load faster. If
you’re using ETags ([`USE_ETAGS = True`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-USE_ETAGS)), you’re already
covered. Otherwise, you can apply [<span>conditional decorators](../../conditional-view-processing/#conditional-decorators). In the following example, the cache is invalidated
whenever you restart your application server.

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.utils <span class="kn">import <span class="n">timezone
<span class="kn">from <span class="nn">django.views.decorators.http <span class="kn">import <span class="n">last_modified
<span class="kn">from <span class="nn">django.views.i18n <span class="kn">import <span class="n">javascript_catalog

<span class="n">last_modified_date <span class="o">= <span class="n">timezone<span class="o">.<span class="n">now<span class="p">()

<span class="nd">@last_modified<span class="p">(<span class="k">lambda <span class="n">req<span class="p">, <span class="o">**<span class="n">kw<span class="p">: <span class="n">last_modified_date<span class="p">)
<span class="k">def <span class="nf">cached_javascript_catalog<span class="p">(<span class="n">request<span class="p">, <span class="n">domain<span class="o">=<span class="s">'djangojs'<span class="p">, <span class="n">packages<span class="o">=<span class="bp">None<span class="p">):
    <span class="k">return <span class="n">javascript_catalog<span class="p">(<span class="n">request<span class="p">, <span class="n">domain<span class="p">, <span class="n">packages<span class="p">)
</pre></div>
</div>

You can even pre-generate the JavaScript catalog as part of your deployment
procedure and serve it as a static file. This radical technique is implemented
in [django-statici18n](http://django-statici18n.readthedocs.org/en/latest/).

## 国际化：在URL模式中[¶](#module-django.conf.urls.i18n "Permalink to this headline")

Django提供了两种机制来国际化URL模式：

*  增加语言前缀到URL模式的根，使得[`LocaleMiddleware`](https://docs.djangoproject.com/en/1.9/ref/middleware/#django.middleware.locale.LocaleMiddleware "django.middleware.locale.LocaleMiddleware")从请求URL中检测激活的语言成为可能。
*  通过[`django.utils.translation.ugettext_lazy()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext_lazy "django.utils.translation.ugettext_lazy")函数使得URL模式自身可翻译。
<div class="admonition warning">

>警告

>无论使用哪一个特性，都需要为每一个请求设置激活语言；也就是说，你需要在设置项中设置[`django.middleware.locale.LocaleMiddleware`](https://docs.djangoproject.com/en/1.9/ref/middleware/#django.middleware.locale.LocaleMiddleware "django.middleware.locale.LocaleMiddleware")。


### URL模式中的语言前缀[¶](#language-prefix-in-url-patterns "Permalink to this headline")

`i18n_patterns`(_prefix_, _pattern_description_, _..._)[**source**](https://docs.djangoproject.com/en/1.9/_modules/django/conf/urls/i18n/#i18n_patterns)[¶](#django.conf.urls.i18n.i18n_patterns "Permalink to this definition")

>从1.8版本起不推荐使用：`i18n_patterns()`的`prefix`参数已被弃用，并将在Django 1.10中不再支持。简单地传递[`django.conf.urls.url()`](https://docs.djangoproject.com/en/1.9/ref/urls/#django.conf.urls.url "django.conf.urls.url")实例列表来替代。



This function can be used in your root URLconf and Django will automatically
prepend the current active language code to all url patterns defined within
[`i18n_patterns()`](#django.conf.urls.i18n.i18n_patterns "django.conf.urls.i18n.i18n_patterns"). Example URL patterns:
```python
from django.conf.urls import include, url
from django.conf.urls.i18n import i18n_patterns

from about import views as about_views
from news import views as news_views
from sitemap.views import sitemap

urlpatterns = [
    url(r'^sitemap\.xml$', sitemap, name='sitemap-xml'),
]

news_patterns = ([
    url(r'^$', news_views.index, name='index'),
    url(r'^category/(?P<slug>[\w-]+)/$', news_views.category, name='category'),
    url(r'^(?P<slug>[\w-]+)/$', news_views.details, name='detail'),
], 'news')

urlpatterns += i18n_patterns(
    url(r'^about/$', about_views.main, name='about'),
    url(r'^news/', include(news_patterns, namespace='news')),
)
```

After defining these URL patterns, Django will automatically add the
language prefix to the URL patterns that were added by the `i18n_patterns`
function. Example:

from django.core.urlresolvers import reverse
from django.utils.translation import activate
```python
>>> activate('en')
>>> reverse('sitemap-xml')
'/sitemap.xml'
>>> reverse('news:index')
'/en/news/'

>>> activate('nl')
>>> reverse('news:detail', kwargs={'slug': 'news-slug'})
'/nl/news/news-slug/'
```

Warning

[`i18n_patterns()`](#django.conf.urls.i18n.i18n_patterns "django.conf.urls.i18n.i18n_patterns") is only allowed in your root
URLconf. Using it within an included URLconf will throw an
[`ImproperlyConfigured`](https://docs.djangoproject.com/en/1.9/ref/exceptions/#django.core.exceptions.ImproperlyConfigured "django.core.exceptions.ImproperlyConfigured") exception.


Warning

Ensure that you don’t have non-prefixed URL patterns that might collide
with an automatically-added language prefix.


### Translating URL patterns[¶](#translating-url-patterns "Permalink to this headline")

URL patterns can also be marked translatable using the
[`ugettext_lazy()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext_lazy "django.utils.translation.ugettext_lazy") function. Example:
```python
from django.conf.urls import include, url
from django.conf.urls.i18n import i18n_patterns
from django.utils.translation import ugettext_lazy as _

from about import views as about_views
from news import views as news_views
from sitemaps.views import sitemap

urlpatterns = [
    url(r'^sitemap\.xml$', sitemap, name='sitemap-xml'),
]

news_patterns = ([
    url(r'^$', news_views.index, name='index'),
    url(_(r'^category/(?P<slug>[\w-]+)/$'), news_views.category, name='category'),
    url(r'^(?P<slug>[\w-]+)/$', news_views.details, name='detail'),
], 'news')

urlpatterns += i18n_patterns(
    url(_(r'^about/$'), about_views.main, name='about'),
    url(_(r'^news/'), include(news_patterns, namespace='news')),
)
```

After you’ve created the translations, the
[`reverse()`](https://docs.djangoproject.com/en/1.9/ref/urlresolvers/#django.core.urlresolvers.reverse "django.core.urlresolvers.reverse") function will return the URL in the
active language. Example:
```python
from django.core.urlresolvers import reverse
from django.utils.translation import activate

>>> activate('en')
>>> reverse('news:category', kwargs={'slug': 'recent'})
'/en/news/category/recent/'

>>> activate('nl')
>>> reverse('news:category', kwargs={'slug': 'recent'})
'/nl/nieuws/categorie/recent/'
```

Warning

In most cases, it’s best to use translated URLs only within a
language-code-prefixed block of patterns (using
[`i18n_patterns()`](#django.conf.urls.i18n.i18n_patterns "django.conf.urls.i18n.i18n_patterns")), to avoid the possibility
that a carelessly translated URL causes a collision with a non-translated
URL pattern.

### Reversing in templates[¶](#reversing-in-templates "Permalink to this headline")

If localized URLs get reversed in templates they always use the current
language. To link to a URL in another language use the [`language`](#std:templatetag-language)
template tag. It enables the given language in the enclosed template section:
```python
{% load i18n %}

{% get_available_languages as languages %}

{% trans "View this category in:" %}
{% for lang_code, lang_name in languages %}
    {% language lang_code %}
    <a href="{% url 'category' slug=category.slug %}">{{ lang_name }}</a>
    {% endlanguage %}
{% endfor %}
```

The [`language`](#std:templatetag-language) tag expects the language code as the only argument.


## 本地化：如何创建语言文件[¶](#localization-how-to-create-language-files "Permalink to this headline")

一旦应用程序的字符串已经被标记为用于后续翻译，那么需要写入（或获得）翻译自身。以下是它如何工作。


### Message files[¶](#message-files "Permalink to this headline")

The first step is to create a [<span class="xref std std-term">message file](../#term-message-file) for a new language. A message
file is a plain-text file, representing a single language, that contains all
available translation strings and how they should be represented in the given
language. Message files have a `.po` file extension.

Django comes with a tool, [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages), that automates the creation and upkeep of these files.

<div class="admonition-gettext-utilities admonition">

Gettext utilities

The `makemessages` command (and `compilemessages` discussed later) use
commands from the GNU gettext toolset: `xgettext`, `msgfmt`,
`msgmerge` and `msguniq`.

The minimum version of the `gettext` utilities supported is 0.15.

</div>

To create or update a message file, run this command:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">makemessages <span class="o">-<span class="nx">l <span class="nx">de
</pre></div>
</div>

...where `de` is the [<span class="xref std std-term">locale name](../#term-locale-name) for the message file you want to
create. For example, `pt_BR` for Brazilian Portuguese, `de_AT` for Austrian
German or `id` for Indonesian.

The script should be run from one of two places:

*   The root directory of your Django project (the one that contains
`manage.py`).
*   The root directory of one of your Django apps.

The script runs over your project source tree or your application source tree
and pulls out all strings marked for translation (see
[<span>How Django discovers translations](#how-django-discovers-translations) and be sure [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS)
is configured correctly). It creates (or updates) a message file in the
directory `locale/LANG/LC_MESSAGES`. In the `de` example, the file will be
`locale/de/LC_MESSAGES/django.po`.

When you run `makemessages` from the root directory of your project, the
extracted strings will be automatically distributed to the proper message files.
That is, a string extracted from a file of an app containing a `locale`
directory will go in a message file under that directory. A string extracted
from a file of an app without any `locale` directory will either go in a
message file under the directory listed first in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) or
will generate an error if [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) is empty.

By default [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) examines every
file that has the `.html` or `.txt` file extension. In case you want to
override that default, use the `--extension` or `-e` option to specify the
file extensions to examine:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">makemessages <span class="o">-<span class="nx">l <span class="nx">de <span class="o">-<span class="nx">e <span class="nx">txt
</pre></div>
</div>

Separate multiple extensions with commas and/or use `-e` or `--extension`
multiple times:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">makemessages <span class="o">-<span class="nx">l <span class="nx">de <span class="o">-<span class="nx">e <span class="nx">html<span class="p">,<span class="nx">txt <span class="o">-<span class="nx">e <span class="nx">xml
</pre></div>
</div>
<div class="admonition warning">

Warning

When [<span>creating message files from JavaScript source code](#creating-message-files-from-js-code) you need to use the special
‘djangojs’ domain, **not** `-e js`.

</div>
<div class="admonition-using-jinja2-templates admonition">

Using Jinja2 templates?

[`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) doesn’t understand the syntax of Jinja2 templates.
To extract strings from a project containing Jinja2 templates, use [Message
Extracting](http://babel.pocoo.org/docs/messages/#message-extraction) from [Babel](http://babel.pocoo.org/) instead.

Here’s an example `babel.cfg` configuration file:

<div class="highlight-javascript"><div class="highlight"><pre># Extraction from Python source files
[python: **.py]

# Extraction from Jinja2 templates
[jinja2: **.jinja]
extensions = jinja2.ext.with_
</pre></div>
</div>

Make sure you list all extensions you’re using! Otherwise Babel won’t
recognize the tags defined by these extensions and will ignore Jinja2
templates containing them entirely.

Babel provides similar features to [`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages), can replace it
in general, and doesn’t depend on `gettext`. For more information, read
its documentation about [working with message catalogs](http://babel.pocoo.org/docs/messages/).

</div>
<div class="admonition-no-gettext admonition">

No gettext?

If you don’t have the `gettext` utilities installed,
[`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) will create empty files. If that’s the case, either
install the `gettext` utilities or just copy the English message file
(`locale/en/LC_MESSAGES/django.po`) if available and use it as a starting
point; it’s just an empty translation file.

</div>
<div class="admonition-working-on-windows admonition">

Working on Windows?

If you’re using Windows and need to install the GNU gettext utilities so
[`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) works, see [<span>gettext on Windows](#gettext-on-windows) for more
information.

</div>

The format of `.po` files is straightforward. Each `.po` file contains a
small bit of metadata, such as the translation maintainer’s contact
information, but the bulk of the file is a list of **messages** – simple
mappings between translation strings and the actual translated text for the
particular language.

For example, if your Django app contained a translation string for the text
`"Welcome to my site."`, like so:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">_<span class="p">(<span class="s2">"Welcome to my site."<span class="p">)
</pre></div>
</div>

...then [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) will have created
a `.po` file containing the following snippet – a message:

<div class="highlight-po"><div class="highlight"><pre><span class="kd">#: path/to/python/module.py:23
<span class="nv">msgid <span class="s">"Welcome to my site."
<span class="nv">msgstr <span class="s">""
</pre></div>
</div>

A quick explanation:

*   `msgid` is the translation string, which appears in the source. Don’t
change it.
*   `msgstr` is where you put the language-specific translation. It starts
out empty, so it’s your responsibility to change it. Make sure you keep
the quotes around your translation.
*   As a convenience, each message includes, in the form of a comment line
prefixed with `#` and located above the `msgid` line, the filename and
line number from which the translation string was gleaned.

Long messages are a special case. There, the first string directly after the
`msgstr` (or `msgid`) is an empty string. Then the content itself will be
written over the next few lines as one string per line. Those strings are
directly concatenated. Don’t forget trailing spaces within the strings;
otherwise, they’ll be tacked together without whitespace!

<div class="admonition-mind-your-charset admonition">

Mind your charset

Due to the way the `gettext` tools work internally and because we want to
allow non-ASCII source strings in Django’s core and your applications, you
**must** use UTF-8 as the encoding for your PO files (the default when PO
files are created).  This means that everybody will be using the same
encoding, which is important when Django processes the PO files.

</div>

To reexamine all source code and templates for new translation strings and
update all message files for **all** languages, run this:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">makemessages <span class="o">-<span class="nx">a
</pre></div>
</div>

### Compiling message files[¶](#compiling-message-files "Permalink to this headline")

After you create your message file – and each time you make changes to it –
you’ll need to compile it into a more efficient form, for use by `gettext`. Do
this with the [`django-admin compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages)
utility.

This tool runs over all available `.po` files and creates `.mo` files, which
are binary files optimized for use by `gettext`. In the same directory from
which you ran [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages), run
[`django-admin compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages) like this:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">compilemessages
</pre></div>
</div>

That’s it. Your translations are ready for use.

<div class="versionchanged">
<span class="title">Changed in Django 1.9:

`compilemessages` now matches the operation of [`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages),
scanning the project tree for `.po` files to compile.

</div>
<div class="admonition-working-on-windows admonition">

Working on Windows?

If you’re using Windows and need to install the GNU gettext utilities so
[`django-admin compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages) works see
[<span>gettext on Windows](#gettext-on-windows) for more information.

</div>
<div class="admonition-po-files-encoding-and-bom-usage admonition">

.po files: Encoding and BOM usage.

Django only supports `.po` files encoded in UTF-8 and without any BOM
(Byte Order Mark) so if your text editor adds such marks to the beginning of
files by default then you will need to reconfigure it.

</div>


### Creating message files from JavaScript source code[¶](#creating-message-files-from-javascript-source-code "Permalink to this headline")

You create and update the message files the same way as the other Django message
files – with the [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) tool.
The only difference is you need to explicitly specify what in gettext parlance
is known as a domain in this case the `djangojs` domain, by providing a `-d
djangojs` parameter, like this:

<div class="highlight-javascript"><div class="highlight"><pre><span class="nx">django<span class="o">-<span class="nx">admin <span class="nx">makemessages <span class="o">-<span class="nx">d <span class="nx">djangojs <span class="o">-<span class="nx">l <span class="nx">de
</pre></div>
</div>

This would create or update the message file for JavaScript for German. After
updating message files, just run [`django-admin compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages) the same way as you do with normal Django message files.


### `gettext` on Windows[¶](#gettext-on-windows "Permalink to this headline")

This is only needed for people who either want to extract message IDs or compile
message files (`.po`). Translation work itself just involves editing existing
files of this type, but if you want to create your own message files, or want to
test or compile a changed message file, you will need the `gettext` utilities:

*   Download the following zip files from the GNOME servers
[https://download.gnome.org/binaries/win32/dependencies/](https://download.gnome.org/binaries/win32/dependencies/)

        *   `gettext-runtime-X.zip`
    *   `gettext-tools-X.zip`

`X` is the version number, we are requiring `0.15` or higher.

*   Extract the contents of the `bin\` directories in both files to the
same folder on your system (i.e. `C:\Program Files\gettext-utils`)

*   Update the system PATH:

        *   `Control Panel &gt; System &gt; Advanced &gt; Environment Variables`.
    *   In the `System variables` list, click `Path`, click `Edit`.
    *   Add `;C:\Program Files\gettext-utils\bin` at the end of the
`Variable value` field.

You may also use `gettext` binaries you have obtained elsewhere, so long as
the `xgettext --version` command works properly. Do not attempt to use Django
translation utilities with a `gettext` package if the command `xgettext
--version` entered at a Windows command prompt causes a popup window saying
“xgettext.exe has generated errors and will be closed by Windows”.


### Customizing the `makemessages` command[¶](#customizing-the-makemessages-command "Permalink to this headline")

If you want to pass additional parameters to `xgettext`, you need to create a
custom [`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) command and override its `xgettext_options`
attribute:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.core.management.commands <span class="kn">import <span class="n">makemessages

<span class="k">class <span class="nc">Command<span class="p">(<span class="n">makemessages<span class="o">.<span class="n">Command<span class="p">):
    <span class="n">xgettext_options <span class="o">= <span class="n">makemessages<span class="o">.<span class="n">Command<span class="o">.<span class="n">xgettext_options <span class="o">+ <span class="p">[<span class="s">'--keyword=mytrans'<span class="p">]
</pre></div>
</div>

If you need more flexibility, you could also add a new argument to your custom
[`makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages) command:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.core.management.commands <span class="kn">import <span class="n">makemessages

<span class="k">class <span class="nc">Command<span class="p">(<span class="n">makemessages<span class="o">.<span class="n">Command<span class="p">):

    <span class="k">def <span class="nf">add_arguments<span class="p">(<span class="bp">self<span class="p">, <span class="n">parser<span class="p">):
        <span class="nb">super<span class="p">(<span class="n">Command<span class="p">, <span class="bp">self<span class="p">)<span class="o">.<span class="n">add_arguments<span class="p">(<span class="n">parser<span class="p">)
        <span class="n">parser<span class="o">.<span class="n">add_argument<span class="p">(<span class="s">'--extra-keyword'<span class="p">, <span class="n">dest<span class="o">=<span class="s">'xgettext_keywords'<span class="p">,
                            <span class="n">action<span class="o">=<span class="s">'append'<span class="p">)

    <span class="k">def <span class="nf">handle<span class="p">(<span class="bp">self<span class="p">, <span class="o">*<span class="n">args<span class="p">, <span class="o">**<span class="n">options<span class="p">):
        <span class="n">xgettext_keywords <span class="o">= <span class="n">options<span class="o">.<span class="n">pop<span class="p">(<span class="s">'xgettext_keywords'<span class="p">)
        <span class="k">if <span class="n">xgettext_keywords<span class="p">:
            <span class="bp">self<span class="o">.<span class="n">xgettext_options <span class="o">= <span class="p">(
                <span class="n">makemessages<span class="o">.<span class="n">Command<span class="o">.<span class="n">xgettext_options<span class="p">[:] <span class="o">+
                <span class="p">[<span class="s">'--keyword=<span class="si">%s<span class="s">' <span class="o">% <span class="n">kwd <span class="k">for <span class="n">kwd <span class="ow">in <span class="n">xgettext_keywords<span class="p">]
            <span class="p">)
        <span class="nb">super<span class="p">(<span class="n">Command<span class="p">, <span class="bp">self<span class="p">)<span class="o">.<span class="n">handle<span class="p">(<span class="o">*<span class="n">args<span class="p">, <span class="o">**<span class="n">options<span class="p">)
</pre></div>
</div>
</div>

## Miscellaneous[¶](#miscellaneous "Permalink to this headline")

### The `set_language` redirect view[¶](#the-set-language-redirect-view "Permalink to this headline")

<dl class="function">
<dt id="django.views.i18n.set_language">
`set_language`(_request_)[<span class="viewcode-link">[source]](https://docs.djangoproject.com/en/1.9/_modules/django/views/i18n/#set_language)[¶](#django.views.i18n.set_language "Permalink to this definition")</dt>
<dd></dd></dl>

As a convenience, Django comes with a view, [`django.views.i18n.set_language()`](#django.views.i18n.set_language "django.views.i18n.set_language"),
that sets a user’s language preference and redirects to a given URL or, by default,
back to the previous page.

Activate this view by adding the following line to your URLconf:

<div class="highlight-python"><div class="highlight"><pre><span class="n">url<span class="p">(<span class="s">r'^i18n/'<span class="p">, <span class="n">include<span class="p">(<span class="s">'django.conf.urls.i18n'<span class="p">)),
</pre></div>
</div>

(Note that this example makes the view available at `/i18n/setlang/`.)

<div class="admonition warning">

Warning

Make sure that you don’t include the above URL within
[`i18n_patterns()`](#django.conf.urls.i18n.i18n_patterns "django.conf.urls.i18n.i18n_patterns") - it needs to be
language-independent itself to work correctly.

</div>

The view expects to be called via the `POST` method, with a `language`
parameter set in request. If session support is enabled, the view
saves the language choice in the user’s session. Otherwise, it saves the
language choice in a cookie that is by default named `django_language`.
(The name can be changed through the [`LANGUAGE_COOKIE_NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_NAME) setting.)

After setting the language choice, Django redirects the user, following this
algorithm:

*   Django looks for a `next` parameter in the `POST` data.
*   If that doesn’t exist, or is empty, Django tries the URL in the
`Referrer` header.
*   If that’s empty – say, if a user’s browser suppresses that header –
then the user will be redirected to `/` (the site root) as a fallback.

Here’s example HTML template code:

<div class="highlight-html+django"><div class="highlight"><pre><span class="cp">{% <span class="k">load <span class="nv">i18n <span class="cp">%}

<span class="nt">&lt;form <span class="na">action=<span class="s">"<span class="cp">{% <span class="k">url <span class="s1">'set_language' <span class="cp">%}<span class="s">" <span class="na">method=<span class="s">"post"<span class="nt">&gt;<span class="cp">{% <span class="k">csrf_token <span class="cp">%}
    <span class="nt">&lt;input <span class="na">name=<span class="s">"next" <span class="na">type=<span class="s">"hidden" <span class="na">value=<span class="s">"<span class="cp">{{ <span class="nv">redirect_to <span class="cp">}}<span class="s">" <span class="nt">/&gt;
    <span class="nt">&lt;select <span class="na">name=<span class="s">"language"<span class="nt">&gt;
        <span class="cp">{% <span class="k">get_current_language <span class="k">as <span class="nv">LANGUAGE_CODE <span class="cp">%}
        <span class="cp">{% <span class="k">get_available_languages <span class="k">as <span class="nv">LANGUAGES <span class="cp">%}
        <span class="cp">{% <span class="k">get_language_info_list <span class="nv">for <span class="nv">LANGUAGES <span class="k">as <span class="nv">languages <span class="cp">%}
        <span class="cp">{% <span class="k">for <span class="nv">language <span class="k">in <span class="nv">languages <span class="cp">%}
            <span class="nt">&lt;option <span class="na">value=<span class="s">"<span class="cp">{{ <span class="nv">language.code <span class="cp">}}<span class="s">"<span class="cp">{% <span class="k">if <span class="nv">language.code <span class="o">== <span class="nv">LANGUAGE_CODE <span class="cp">%} <span class="na">selected=<span class="s">"selected"<span class="cp">{% <span class="k">endif <span class="cp">%}<span class="nt">&gt;
                <span class="cp">{{ <span class="nv">language.name_local <span class="cp">}} (<span class="cp">{{ <span class="nv">language.code <span class="cp">}})
            <span class="nt">&lt;/option&gt;
        <span class="cp">{% <span class="k">endfor <span class="cp">%}
    <span class="nt">&lt;/select&gt;
    <span class="nt">&lt;input <span class="na">type=<span class="s">"submit" <span class="na">value=<span class="s">"Go" <span class="nt">/&gt;
<span class="nt">&lt;/form&gt;
</pre></div>
</div>

In this example, Django looks up the URL of the page to which the user will be
redirected in the `redirect_to` context variable.


### Explicitly setting the active language[¶](#explicitly-setting-the-active-language "Permalink to this headline")

You may want to set the active language for the current session explicitly. Perhaps
a user’s language preference is retrieved from another system, for example.
You’ve already been introduced to [`django.utils.translation.activate()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.activate "django.utils.translation.activate"). That
applies to the current thread only. To persist the language for the entire
session, also modify [`LANGUAGE_SESSION_KEY`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.LANGUAGE_SESSION_KEY "django.utils.translation.LANGUAGE_SESSION_KEY")
in the session:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.utils <span class="kn">import <span class="n">translation
<span class="n">user_language <span class="o">= <span class="s">'fr'
<span class="n">translation<span class="o">.<span class="n">activate<span class="p">(<span class="n">user_language<span class="p">)
<span class="n">request<span class="o">.<span class="n">session<span class="p">[<span class="n">translation<span class="o">.<span class="n">LANGUAGE_SESSION_KEY<span class="p">] <span class="o">= <span class="n">user_language
</pre></div>
</div>

You would typically want to use both: [`django.utils.translation.activate()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.activate "django.utils.translation.activate")
will change the language for this thread, and modifying the session makes this
preference persist in future requests.

If you are not using sessions, the language will persist in a cookie, whose name
is configured in [`LANGUAGE_COOKIE_NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_NAME). For example:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.utils <span class="kn">import <span class="n">translation
<span class="kn">from <span class="nn">django <span class="kn">import <span class="n">http
<span class="kn">from <span class="nn">django.conf <span class="kn">import <span class="n">settings
<span class="n">user_language <span class="o">= <span class="s">'fr'
<span class="n">translation<span class="o">.<span class="n">activate<span class="p">(<span class="n">user_language<span class="p">)
<span class="n">response <span class="o">= <span class="n">http<span class="o">.<span class="n">HttpResponse<span class="p">(<span class="o">...<span class="p">)
<span class="n">response<span class="o">.<span class="n">set_cookie<span class="p">(<span class="n">settings<span class="o">.<span class="n">LANGUAGE_COOKIE_NAME<span class="p">, <span class="n">user_language<span class="p">)
</pre></div>
</div>

### Using translations outside views and templates[¶](#using-translations-outside-views-and-templates "Permalink to this headline")

While Django provides a rich set of i18n tools for use in views and templates,
it does not restrict the usage to Django-specific code. The Django translation
mechanisms can be used to translate arbitrary texts to any language that is
supported by Django (as long as an appropriate translation catalog exists, of
course). You can load a translation catalog, activate it and translate text to
language of your choice, but remember to switch back to original language, as
activating a translation catalog is done on per-thread basis and such change
will affect code running in the same thread.

For example:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.utils <span class="kn">import <span class="n">translation

<span class="k">def <span class="nf">welcome_translated<span class="p">(<span class="n">language<span class="p">):
    <span class="n">cur_language <span class="o">= <span class="n">translation<span class="o">.<span class="n">get_language<span class="p">()
    <span class="k">try<span class="p">:
        <span class="n">translation<span class="o">.<span class="n">activate<span class="p">(<span class="n">language<span class="p">)
        <span class="n">text <span class="o">= <span class="n">translation<span class="o">.<span class="n">ugettext<span class="p">(<span class="s">'welcome'<span class="p">)
    <span class="k">finally<span class="p">:
        <span class="n">translation<span class="o">.<span class="n">activate<span class="p">(<span class="n">cur_language<span class="p">)
    <span class="k">return <span class="n">text
</pre></div>
</div>

Calling this function with the value ‘de’ will give you `"Willkommen"`,
regardless of [`LANGUAGE_CODE`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_CODE) and language set by middleware.

Functions of particular interest are
[`django.utils.translation.get_language()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.get_language "django.utils.translation.get_language") which returns the language used
in the current thread, [`django.utils.translation.activate()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.activate "django.utils.translation.activate") which
activates a translation catalog for the current thread, and
[`django.utils.translation.check_for_language()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.check_for_language "django.utils.translation.check_for_language")
which checks if the given language is supported by Django.

To help write more concise code, there is also a context manager
[`django.utils.translation.override()`](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.override "django.utils.translation.override") that stores the current language on
enter and restores it on exit. With it, the above example becomes:

<div class="highlight-python"><div class="highlight"><pre><span class="kn">from <span class="nn">django.utils <span class="kn">import <span class="n">translation

<span class="k">def <span class="nf">welcome_translated<span class="p">(<span class="n">language<span class="p">):
    <span class="k">with <span class="n">translation<span class="o">.<span class="n">override<span class="p">(<span class="n">language<span class="p">):
        <span class="k">return <span class="n">translation<span class="o">.<span class="n">ugettext<span class="p">(<span class="s">'welcome'<span class="p">)
</pre></div>
</div>

### Language cookie[¶](#language-cookie "Permalink to this headline")

A number of settings can be used to adjust language cookie options:

*   [`LANGUAGE_COOKIE_NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_NAME)
*   [`LANGUAGE_COOKIE_AGE`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_AGE)
*   [`LANGUAGE_COOKIE_DOMAIN`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_DOMAIN)
*   [`LANGUAGE_COOKIE_PATH`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_PATH)

## Implementation notes[¶](#implementation-notes "Permalink to this headline")

### Specialties of Django translation[¶](#specialties-of-django-translation "Permalink to this headline")

Django’s translation machinery uses the standard `gettext` module that comes
with Python. If you know `gettext`, you might note these specialties in the
way Django does translation:

*   The string domain is `django` or `djangojs`. This string domain is
used to differentiate between different programs that store their data
in a common message-file library (usually `/usr/share/locale/`). The
`django` domain is used for Python and template translation strings
and is loaded into the global translation catalogs. The `djangojs`
domain is only used for JavaScript translation catalogs to make sure
that those are as small as possible.
*   Django doesn’t use `xgettext` alone. It uses Python wrappers around
`xgettext` and `msgfmt`. This is mostly for convenience.


### Django如何发现语言首选项[¶](#how-django-discovers-language-preference "Permalink to this headline")

一旦你准备你的翻译 - 或者，如果你只是想用Django附带的翻译 - 你只需要为你的应用程序激活翻译。

在幕后，Django有一种非常灵活的模型来决定应该使用哪种语言的 - 安装范围，为特定的用户，或两者兼而有之。

要设置安装范围的语言首选项，设置`LANGUAGE_CODE`。Django使用该语言作为默认翻译-如果没有更好的可匹配的翻译，那么会通过在区域设置中间件所采用的方法之一中找到最后的尝试（见下文）。

如果你只是想要使用你的母语来运行Django，你所需要做的是设置[LANGUAGE_CODE](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_CODE)，并确保对应的[消息文件](https://docs.djangoproject.com/en/1.9/topics/i18n/#term-message-file)及它们的编译版本(.mo)存在。

如果你想要让每个用户指定他们喜欢的语言，那么你还需要使用LocaleMiddleware。LocaleMiddleware使语言选择基于来自请求的数据。它为每个用户自定义内容。

要使用LocaleMiddleware，在MIDDLEWARE_CLASSES设置上加上 “django.middleware.locale.LocaleMiddleware' 。由于中间件的顺序会有影响，所以应遵循以下原则：

* 请确保它是安装的第一个中间件之一。
* 它应该在SessionMiddleware之后，因为LocaleMiddleware 会利用会话数据。它应该在CommonMiddleware之前， 因为CommonMiddleware需要激活的语言来解析请求的URL。
* 如果你使用CacheMiddleware，把 LocaleMiddleware放在其后。
例如，您的[MIDDLEWARE_CLASSES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-MIDDLEWARE_CLASSES)可能是这样的：
```python
MIDDLEWARE_CLASSES = [
   'django.contrib.sessions.middleware.SessionMiddleware',
   'django.middleware.locale.LocaleMiddleware',
   'django.middleware.common.CommonMiddleware',
]
```
(更多关于中间件的内容，见[中间件文档](https://docs.djangoproject.com/en/1.9/topics/http/middleware/)。)

LocaleMiddleware试图按照下面算法来确定用户的语言首选项：

* 首先，它会在请求的URL中查找语言前缀。这只有当你在你的根URL中使用i18n_patterns函数时才会进行。见[国际化：URL模式](https://docs.djangoproject.com/en/1.9/topics/i18n/translation/#url-internationalization)以获得更多有关语言前缀，以及如何国际化URL模式的信息。

* 如果做不到这一点，它会在当前用户的会话中寻找[LANGUAGE_SESSION_KEY](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.LANGUAGE_SESSION_KEY)键。

* 如果做不到这一点，它会寻找一个cookie。

    所使用的cookie的名称是由设置项[LANGUAGE_COOKIE_NAME](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_COOKIE_NAME)设置的。（默认名称为`django_language`。）

* 如果做不到这一点，它查找HTTP标头的Accept-Language。这个标头是由浏览器发送，并通知服务器优先使用的语言，以优先级的顺序。Django尝试标头中的每种语言，直到找到一个可用的翻译。

* 如果做不到这一点，它使用全局[LANGUAGE_CODE](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGE_CODE)设置项。

注意：

* 在这些地方，语言首选项是满足标准语言格式的一个字符串。例如，巴西葡萄牙语是pt-br。

* 如果基本语言可用，但指定的子语言不可用，Django使用基本语言。例如，如果用户指定de-at （奥地利德国），但Django只有de可用，那么Django使用de。

* 只能选择在[LANGUAGES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGES)设置项中列举的语言。如果你想限制语言选择至一个给定语言的子集（因为你的应用程序不提供所有语言），设置[LANGUAGES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGES)为一个语言列表。例如：
    ```python
    LANGUAGES = [
      ('de', _('German')),
      ('en', _('English')),
    ]
    ```
    这个例子限制了可供自动选择的语言为德语和英语（以及任意子语言，如de-ch或en-us）。

* 如果你如前面的解释定义了一个自定义[LANGUAGES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LANGUAGES)设置，那么可以标记语言名称为翻译字符串-但使用[ugettext_lazy()](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext_lazy)代替[ugettext()](https://docs.djangoproject.com/en/1.9/ref/utils/#django.utils.translation.ugettext)，以避免循环导入。

   下面是一个示例设置文件：
```python
from django.utils.translation import ugettext_lazy as _

LANGUAGES = [
    ('de', _('German')),
    ('en', _('English')),
]
```
 一旦`LocaleMiddleware`确定了用户的首选项，对于每一个[`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest")，都可以通过`request.LANGUAGE_CODE`来访问这个首选项。随时在您的视图代码中读取此值。这里有一个简单的例子：
```python
from django.http import HttpResponse

def hello_world(request, count):
    if request.LANGUAGE_CODE == 'de-at':
        return HttpResponse("You prefer to read Austrian German.")
    else:
        return HttpResponse("You prefer to read another language.")
```
需要注意的是，使用静态（middleware-less）翻译，该语言则位于`settings.LANGUAGE_CODE`，而使用动态（middleware）翻译，它则位于`request.LANGUAGE_CODE`。


### Django如何发现翻译(translations)[¶](#how-django-discovers-translations "Permalink to this headline")

To achieve this it looks for translations by following this algorithm regarding
the order in which it examines the different file paths to load the compiled
[message files](../#term-message-file) (`.mo`) and the precedence of multiple
translations for the same literal:在运行时，Django建立一个关于文字翻译的位于内存中的统一目录。要按照这个算法就在其中探讨了不同的文件路径的顺序来加载编译做到这一点，它看起来对翻译 消息文件（的.mo）和多重翻译的文字相同的优先级：

1.  The directories listed in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) have the highest
precedence, with the ones appearing first having higher precedence than
the ones appearing later.
2.  Then, it looks for and uses if it exists a `locale` directory in each
of the installed apps listed in [`INSTALLED_APPS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-INSTALLED_APPS).  The ones
appearing first have higher precedence than the ones appearing later.
3.  Finally, the Django-provided base translation in `django/conf/locale`
is used as a fallback.
<div class="admonition seealso">

See also

The translations for literals included in JavaScript assets are looked up
following a similar but not identical algorithm. See the
[<span>javascript_catalog view documentation](#javascript-catalog-view) for
more details.

</div>

In all cases the name of the directory containing the translation is expected to
be named using [<span class="xref std std-term">locale name](../#term-locale-name) notation. E.g. `de`, `pt_BR`, `es_AR`,
etc.

This way, you can write applications that include their own translations, and
you can override base translations in your project. Or, you can just build
a big project out of several apps and put all translations into one big common
message file specific to the project you are composing. The choice is yours.

All message file repositories are structured the same way. They are:

*   All paths listed in [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) in your settings file are
searched for `&lt;language&gt;/LC_MESSAGES/django.(po|mo)`
*   `$APPPATH/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)`
*   `$PYTHONPATH/django/conf/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)`

To create message files, you use the [`django-admin makemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-makemessages)
tool. And you use [`django-admin compilemessages`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages)
to produce the binary `.mo` files that are used by `gettext`.

You can also run [`django-admin compilemessages
--settings=path.to.settings`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-compilemessages) to make the compiler process all
the directories in your [`LOCALE_PATHS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-LOCALE_PATHS) setting.
