原文：[Templates](https://docs.djangoproject.com/en/1.9/topics/templates/)

---

Being a web framework, Django needs a convenient way to generate HTML
dynamically. The most common approach relies on templates. A template contains
the static parts of the desired HTML output as well as some special syntax
describing how dynamic content will be inserted. For a hands-on example of
creating HTML pages with templates, see [_Tutorial 3_](https://docs.djangoproject.com/en/1.9/intro/tutorial03/).

A Django project can be configured with one or several template engines (or
even zero if you don’t use templates). Django ships built-in backends for its
own template system, creatively called the Django template language (DTL), and
for the popular alternative [Jinja2](http://jinja.pocoo.org/). Backends for other template languages may
be available from third-parties.

Django defines a standard API for loading and rendering templates regardless
of the backend. Loading consists of finding the template for a given identifier
and preprocessing it, usually compiling it to an in-memory representation.
Rendering means interpolating the template with context data and returning the
resulting string.

The [_Django template language_](https://docs.djangoproject.com/en/1.9/ref/templates/language/) is Django’s own
template system. Until Django 1.8 it was the only built-in option available.
It’s a good template library even though it’s fairly opinionated and sports a
few idiosyncrasies. If you don’t have a pressing reason to choose another
backend, you should use the DTL, especially if you’re writing a pluggable
application and you intend to distribute templates. Django’s contrib apps that
include templates, like [_django.contrib.admin_](https://docs.djangoproject.com/en/1.9/ref/contrib/admin/),
use the DTL.

For historical reasons, both the generic support for template engines and the
implementation of the Django template language live in the `django.template`
namespace.


## 模板引擎支持[¶](#support-for-template-engines "Permalink to this headline")

>Django 1.8新特性

>Support for multiple template engines and the [`TEMPLATES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES) setting
were added in Django 1.8.


### 配置[¶](#configuration "Permalink to this headline")

Templates engines are configured with the [`TEMPLATES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES) setting. It’s a
list of configurations, one for each engine. The default value is empty. The
`settings.py` generated by the [`startproject`](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-startproject) command defines a
more useful value:
```py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            # ... some options here ...
        },
    },
]
```

[`BACKEND`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-BACKEND) is a dotted Python path to a template
engine class implementing Django’s template backend API. The built-in backends
are [`django.template.backends.django.DjangoTemplates`](#django.template.backends.django.DjangoTemplates "django.template.backends.django.DjangoTemplates") and
[`django.template.backends.jinja2.Jinja2`](#django.template.backends.jinja2.Jinja2 "django.template.backends.jinja2.Jinja2").

Since most engines load templates from files, the top-level configuration for
each engine contains two common settings:

*   [`DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-DIRS) defines a list of directories where the
engine should look for template source files, in search order.
*   [`APP_DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-APP_DIRS) tells whether the engine should
look for templates inside installed applications. Each backend defines a
conventional name for the subdirectory inside applications where its
templates should be stored.

While uncommon, it’s possible to configure several instances of the same
backend with different options. In that case you should define a unique
[`NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-NAME) for each engine.

[`OPTIONS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-OPTIONS) contains backend-specific settings.


### 用法[¶](#usage "Permalink to this headline")

The `django.template.loader` module defines two functions to load templates.

`get_template`(_template_name_, _dirs=_dirs_undefined_, _using=None_)[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#get_template)[¶](#django.template.loader.get_template "Permalink to this definition")

This function loads the template with the given name and returns a
`Template` object.

The exact type of the return value depends on the backend that loaded the
template. Each backend has its own `Template` class.

`get_template()` tries each template engine in order until one succeeds.
If the template cannot be found, it raises
[`TemplateDoesNotExist`](#django.template.TemplateDoesNotExist "django.template.TemplateDoesNotExist"). If the template is found but
contains invalid syntax, it raises
[`TemplateSyntaxError`](#django.template.TemplateSyntaxError "django.template.TemplateSyntaxError").

How templates are searched and loaded depends on each engine’s backend and
configuration.

If you want to restrict the search to a particular template engine, pass
the engine’s [`NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-NAME) in the `using` argument.

>Deprecated since version 1.8:
>The `dirs` parameter was deprecated.

>Changed in Django 1.8:
>The `using` parameter was added.

>Changed in Django 1.8:

`get_template()` returns a backend-dependent `Template` instead
of a [`django.template.Template`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template "django.template.Template").


`select_template`(_template_name_list_, _dirs=_dirs_undefined_, _using=None_)[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#select_template)[¶](#django.template.loader.select_template "Permalink to this definition")


`select_template()` is just like `get_template()`, except it takes a
list of template names. It tries each name in order and returns the first
template that exists.

>Deprecated since version 1.8: The `dirs` parameter was deprecated.

>Changed in Django 1.8:

The `using` parameter was added.

>Changed in Django 1.8:

`select_template()` returns a backend-dependent `Template` instead
of a [`django.template.Template`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template "django.template.Template").


If loading a template fails, the following two exceptions, defined in
`django.template`, may be raised:

_exception _`TemplateDoesNotExist`(_msg_, _tried=None_, _backend=None_, _chain=None_)[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/exceptions/#TemplateDoesNotExist)[¶](#django.template.TemplateDoesNotExist "Permalink to this definition")


This exception is raised when a template cannot be found. It accepts the
following optional arguments for populating the [<span>template postmortem](#template-postmortem) on the debug page:

`backend`
The template backend instance from which the exception originated.
`tried`
A list of sources that were tried when finding the template. This is
formatted as a list of tuples containing `(origin, status)`, where
`origin` is an [<span>origin-like](#template-origin-api) object and
`status` is a string with the reason the template wasn’t found.
`chain`
A list of intermediate [`TemplateDoesNotExist`](#django.template.TemplateDoesNotExist "django.template.TemplateDoesNotExist")
exceptions raised when trying to load a template. This is used by
functions, such as [`get_template()`](#django.template.loader.get_template "django.template.loader.get_template"), that
try to load a given template from multiple engines.

>New in Django 1.9:

The `backend`, `tried`, and `chain` arguments were added.


_exception _`TemplateSyntaxError`(_msg_)[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/exceptions/#TemplateSyntaxError)[¶](#django.template.TemplateSyntaxError "Permalink to this definition")


This exception is raised when a template was found but contains errors.



`Template` objects returned by `get_template()` and `select_template()`
must provide a `render()` method with the following signature:

`Template.``render`(_context=None_, _request=None_)[¶](#django.template.backends.base.Template.render "Permalink to this definition")


Renders this template with a given context.

If `context` is provided, it must be a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.5)"). If it isn’t
provided, the engine will render the template with an empty context.

If `request` is provided, it must be an [`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest").
Then the engine must make it, as well as the CSRF token, available in the
template. How this is achieved is up to each backend.



Here’s an example of the search algorithm. For this example the
[`TEMPLATES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES) setting is:
```py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            '/home/html/example.com',
            '/home/html/default',
        ],
    },
    {
        'BACKEND': 'django.template.backends.jinja2.Jinja2',
        'DIRS': [
            '/home/html/jinja2',
        ],
    },
]
```

If you call `get_template('story_detail.html')`, here are the files Django
will look for, in order:

*   `/home/html/example.com/story_detail.html` (`'django'` engine)
*   `/home/html/default/story_detail.html` (`'django'` engine)
*   `/home/html/jinja2/story_detail.html` (`'jinja2'` engine)

If you call `select_template(['story_253_detail.html', 'story_detail.html'])`,
here’s what Django will look for:

*   `/home/html/example.com/story_253_detail.html` (`'django'` engine)
*   `/home/html/default/story_253_detail.html` (`'django'` engine)
*   `/home/html/jinja2/story_253_detail.html` (`'jinja2'` engine)
*   `/home/html/example.com/story_detail.html` (`'django'` engine)
*   `/home/html/default/story_detail.html` (`'django'` engine)
*   `/home/html/jinja2/story_detail.html` (`'jinja2'` engine)

When Django finds a template that exists, it stops looking.

>Tip

>You can use [`select_template()`](#django.template.loader.select_template "django.template.loader.select_template") for flexible
template loading. For example, if you’ve written a news story and want
some stories to have custom templates, use something like
`select_template(['story_%s_detail.html' % story.id,
'story_detail.html'])`. That’ll allow you to use a custom template for an
individual story, with a fallback template for stories that don’t have
custom templates.



It’s possible – and preferable – to organize templates in subdirectories
inside each directory containing templates. The convention is to make a
subdirectory for each Django app, with subdirectories within those
subdirectories as needed.

Do this for your own sanity. Storing all templates in the root level of a
single directory gets messy.

To load a template that’s within a subdirectory, just use a slash, like so:
```py
get_template('news/story_detail.html')
```

Using the same [`TEMPLATES`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES) option as above, this will attempt to load
the following templates:

*   `/home/html/example.com/news/story_detail.html` (`'django'` engine)
*   `/home/html/default/news/story_detail.html` (`'django'` engine)
*   `/home/html/jinja2/news/story_detail.html` (`'jinja2'` engine)

In addition, to cut down on the repetitive nature of loading and rendering
templates, Django provides a shortcut function which automates the process.

`render_to_string`(_template_name_, _context=None_, _context_instance=_context_instance_undefined_, _request=None_, _using=None_)[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/loader/#render_to_string)[¶](#django.template.loader.render_to_string "Permalink to this definition")


`render_to_string()` loads a template like [`get_template()`](#django.template.loader.get_template "django.template.loader.get_template") and
calls its `render()` method immediately. It takes the following
arguments.

`template_name`
The name of the template to load and render. If it’s a list of template
names, Django uses [`select_template()`](#django.template.loader.select_template "django.template.loader.select_template") instead of
[`get_template()`](#django.template.loader.get_template "django.template.loader.get_template") to find the template.
`context`


A [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.5)") to be used as the template’s context for rendering.

>Changed in Django 1.8:

>The `context` argument used to be called `dictionary`. That name
is deprecated in Django 1.8 and will be removed in Django 1.10.

>`context` is now optional. An empty context will be used if it
isn’t provided.



`context_instance`


An instance of [`Context`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Context "django.template.Context") or a subclass (e.g., an
instance of [`RequestContext`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.RequestContext "django.template.RequestContext")) to use as the
template’s context.

>Deprecated since version 1.8: The `context_instance` argument is deprecated. Use `context` and
if needed `request`.



`request`


An optional [`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest") that will be available
during the template’s rendering process.

>Django 1.8新特性

The `request` argument was added.






See also the [`render()`](../http/shortcuts/#django.shortcuts.render "django.shortcuts.render") shortcut which calls
[`render_to_string()`](#django.template.loader.render_to_string "django.template.loader.render_to_string") and feeds the result into an
[`HttpResponse`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpResponse "django.http.HttpResponse") suitable for returning from a view.

Finally, you can use configured engines directly:

`engines`[¶](#django.template.loader.engines "Permalink to this definition")


Template engines are available in `django.template.engines`:
```py
from django.template import engines

django_engine = engines['django']
template = django_engine.from_string("Hello {{ name }}!")
```

The lookup key — `'django'` in this example — is the engine’s
[`NAME`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-NAME).




### 内置后端[¶](#module-django.template.backends.django "Permalink to this headline")

_class _`DjangoTemplates`[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/backends/django/#DjangoTemplates)[¶](#django.template.backends.django.DjangoTemplates "Permalink to this definition")


Set [`BACKEND`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-BACKEND) to
`'django.template.backends.django.DjangoTemplates'` to configure a Django
template engine.

When [`APP_DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-APP_DIRS) is `True`, `DjangoTemplates`
engines look for templates in the `templates` subdirectory of installed
applications. This generic name was kept for backwards-compatibility.

`DjangoTemplates` engines accept the following [`OPTIONS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-OPTIONS):

*   `'allowed_include_roots'`: a list of strings representing allowed prefixes
for the `{% ssi %}` template tag. This is a security measure, so that
template authors can’t access files that they shouldn’t be accessing.

    For example, if `'allowed_include_roots'` is `['/home/html',
'/var/www']`, then `{% ssi /home/html/foo.txt %}` would work, but `{%
ssi /etc/passwd %}` wouldn’t.

    It defaults to an empty list.

>Deprecated since version 1.8: `allowed_include_roots` is deprecated because the {% ssi %} tag is
deprecated.



*   `'context_processors'`: a list of dotted Python paths to callables that
are used to populate the context when a template is rendered with a request.
These callables take a request object as their argument and return a
[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.5)") of items to be merged into the context.

    It defaults to an empty list.

    See [`RequestContext`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.RequestContext "django.template.RequestContext") for more information.

*   `'debug'`: a boolean that turns on/off template debug mode. If it is
`True`, the fancy error page will display a detailed report for any
exception raised during template rendering. This report contains the
relevant snippet of the template with the appropriate line highlighted.

    It defaults to the value of the [`DEBUG`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-DEBUG) setting.

*   `'loaders'`: a list of dotted Python paths to template loader classes.
Each `Loader` class knows how to import templates from a particular
source. Optionally, a tuple can be used instead of a string. The first item
in the tuple should be the `Loader` class name, and subsequent items are
passed to the `Loader` during initialization.

    The default depends on the values of [`DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-DIRS) and
[`APP_DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-APP_DIRS).

    See [<span>Loader types](https://docs.djangoproject.com/en/1.9/ref/templates/api/#template-loaders) for details.

*   `'string_if_invalid'`: the output, as a string, that the template system
should use for invalid (e.g. misspelled) variables.

    It defaults to an empty string.

    See [<span>How invalid variables are handled](https://docs.djangoproject.com/en/1.9/ref/templates/api/#invalid-template-variables) for details.

*   `'file_charset'`: the charset used to read template files on disk.

    It defaults to the value of [`FILE_CHARSET`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-FILE_CHARSET).

*   `'libraries'`: A dictionary of labels and dotted Python paths of template
tag modules to register with the template engine. This can be used to add
new libraries or provide alternate labels for existing ones. For example:
```py
OPTIONS={
'libraries': {
    'myapp_tags': 'path.to.myapp.tags',
    'admin.urls': 'django.contrib.admin.templatetags.admin_urls',
},
}
```

Libraries can be loaded by passing the corresponding dictionary key to
the [`{% load %}`](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#std:templatetag-load) tag.

*   `'builtins'`: A list of dotted Python paths of template tag modules to
add to [_built-ins_](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/). For example:
```py
OPTIONS={
    'builtins': ['myapp.builtins'],
}
```

Tags and filters from built-in libraries can be used without first calling
the [`{% load %}`](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#std:templatetag-load) tag.
>New in Django 1.9:

>The `libraries` and `builtins` arguments were added.


_class _`Jinja2`[[source]](https://docs.djangoproject.com/en/1.9/_modules/django/template/backends/jinja2/#Jinja2)[¶](#django.template.backends.jinja2.Jinja2 "Permalink to this definition")


Requires [Jinja2](http://jinja.pocoo.org/) to be installed:
```sh
$ pip install Jinja2
```

Set [`BACKEND`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-BACKEND) to
`'django.template.backends.jinja2.Jinja2'` to configure a [Jinja2](http://jinja.pocoo.org/) engine.

When [`APP_DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-APP_DIRS) is `True`, `Jinja2` engines
look for templates in the `jinja2` subdirectory of installed applications.

The most important entry in [`OPTIONS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-OPTIONS) is
`'environment'`. It’s a dotted Python path to a callable returning a Jinja2
environment. It defaults to `'jinja2.Environment'`. Django invokes that
callable and passes other options as keyword arguments. Furthermore, Django
adds defaults that differ from Jinja2’s for a few options:

*   `'autoescape'`: `True`
*   `'loader'`: a loader configured for [`DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-DIRS) and
[`APP_DIRS`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES-APP_DIRS)
*   `'auto_reload'`: `settings.DEBUG`
*   `'undefined'`: `DebugUndefined if settings.DEBUG else Undefined`

The default configuration is purposefully kept to a minimum. The `Jinja2`
backend doesn’t create a Django-flavored environment. It doesn’t know about
Django context processors, filters, and tags. In order to use Django-specific
APIs, you must configure them into the environment.

For example, you can create `myproject/jinja2.py` with this content:

```py
from __future__ import absolute_import  # Python 2 only

from django.contrib.staticfiles.storage import staticfiles_storage
from django.core.urlresolvers import reverse

from jinja2 import Environment


def environment(**options):
    env = Environment(**options)
    env.globals.update({
        'static': staticfiles_storage.url,
        'url': reverse,
    })
    return env
```

and set the `'environment'` option to `'myproject.jinja2.environment'`.

Then you could use the following constructs in Jinja2 templates:
```html
<img src="{{ static('path/to/company-logo.png') }}" alt="Company Logo">

<a href="{{ url('admin:index') }}">Administration</a>
```

The concepts of tags and filters exist both in the Django template language
and in Jinja2 but they’re used differently. Since Jinja2 supports passing
arguments to callables in templates, many features that require a template tag
or filter in Django templates can be achieved simply by calling a function in
Jinja2 templates, as shown in the example above. Jinja2’s global namespace
removes the need for template context processors. The Django template language
doesn’t have an equivalent of Jinja2 tests.


### 自定义后端[¶](#custom-backends "Permalink to this headline")

Here’s how to implement a custom template backend in order to use another
template system. A template backend is a class that inherits
`django.template.backends.base.BaseEngine`. It must implement
`get_template()` and optionally `from_string()`. Here’s an example for a
fictional `foobar` template library:
```py
from django.template import TemplateDoesNotExist, TemplateSyntaxError
from django.template.backends.base import BaseEngine
from django.template.backends.utils import csrf_input_lazy, csrf_token_lazy

import foobar


class FooBar(BaseEngine):

    # Name of the subdirectory containing the templates for this engine
    # inside an installed application.
    app_dirname = 'foobar'

    def __init__(self, params):
        params = params.copy()
        options = params.pop('OPTIONS').copy()
        super(FooBar, self).__init__(params)

        self.engine = foobar.Engine(**options)

    def from_string(self, template_code):
        try:
          return Template(self.engine.from_string(template_code))
        except foobar.TemplateCompilationFailed as exc:
            raise TemplateSyntaxError(exc.args)

    def get_template(self, template_name):
        try:
            return Template(self.engine.get_template(template_name))
        except foobar.TemplateNotFound as exc:
            raise TemplateDoesNotExist(exc.args, backend=self)
        except foobar.TemplateCompilationFailed as exc:
            raise TemplateSyntaxError(exc.args)


class Template(object):

    def __init__(self, template):
        self.template = template

    def render(self, context=None, request=None):
        if context is None:
            context = {}
        if request is not None:
            context['request'] = request
            context['csrf_input'] = csrf_input_lazy(request)
            context['csrf_token'] = csrf_token_lazy(request)
        return self.template.render(context)
```

See [DEP 182](https://github.com/django/deps/blob/master/accepted/0182-multiple-template-engines.rst) for more information.



### 自定义引擎的调试集成[¶](#debug-integration-for-custom-engines "Permalink to this headline")

>New in Django 1.9:

Debug page integration for non-Django template engines was added.



The Django debug page has hooks to provide detailed information when a template
error arises. Custom template engines can use these hooks to enhance the
traceback information that appears to users. The following hooks are available:


#### 模板事后析误[¶](#template-postmortem "Permalink to this headline")

The postmortem appears when [`TemplateDoesNotExist`](#django.template.TemplateDoesNotExist "django.template.TemplateDoesNotExist") is
raised. It lists the template engines and loaders that were used when trying
to find a given template. For example, if two Django engines are configured,
the postmortem will appear like:

!https://docs.djangoproject.com/en/1.9/_images/postmortem.png](https://docs.djangoproject.com/en/1.9/_images/postmortem.png)

Custom engines can populate the postmortem by passing the `backend` and
`tried` arguments when raising [`TemplateDoesNotExist`](#django.template.TemplateDoesNotExist "django.template.TemplateDoesNotExist").
Backends that use the postmortem [<span>should specify an origin](#template-origin-api) on the template object.


#### 上下文行信息[¶](#contextual-line-information "Permalink to this headline")

If an error happens during template parsing or rendering, Django can display
the line the error happened on. For example:

![https://docs.djangoproject.com/en/1.9/_images/template-lines.png](https://docs.djangoproject.com/en/1.9/_images/template-lines.png)

Custom engines can populate this information by setting a `template_debug`
attribute on exceptions raised during parsing and rendering. This attribute
is a [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.5)") with the following values:

*   `'name'`: The name of the template in which the exception occurred.
*   `'message'`: The exception message.
*   `'source_lines'`: The lines before, after, and including the line the
exception occurred on. This is for context, so it shouldn’t contain more than
20 lines or so.
*   `'line'`: The line number on which the exception occurred.
*   `'before'`: The content on the error line before the token that raised the
error.
*   `'during'`: The token that raised the error.
*   `'after'`: The content on the error line after the token that raised the
error.
*   `'total'`: The number of lines in `source_lines`.
*   `'top'`: The line number where `source_lines` starts.
*   `'bottom'`: The line number where `source_lines` ends.

Given the above template error, `template_debug` would look like:
```py
{
    'name': '/path/to/template.html',
    'message': "Invalid block tag: 'syntax'",
    'source_lines': [
        (1, 'some\n'),
        (2, 'lines\n'),
        (3, 'before\n'),
        (4, 'Hello {% syntax error %} {{ world }}\n'),
        (5, 'some\n'),
        (6, 'lines\n'),
        (7, 'after\n'),
        (8, ''),
    ],
    'line': 4,
    'before': 'Hello ',
    'during': '{% syntax error %}',
    'after': ' {{ world }}\n',
    'total': 9,
    'bottom': 9,
    'top': 1,
}
```


#### 原始API和第三方集成[¶](#origin-api-and-3rd-party-integration "Permalink to this headline")

Django templates have an [`Origin`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.base.Origin "django.template.base.Origin") object available
through the `template.origin` attribute. This enables debug information to be
displayed in the [<span>template postmortem](#template-postmortem), as well as
in 3rd-party libraries, like the [Django Debug Toolbar](https://github.com/django-debug-toolbar/django-debug-toolbar).

Custom engines can provide their own `template.origin` information by
creating an object that specifies the following attributes:

*   `'name'`: The full path to the template.
*   `'template_name'`: The relative path to the template as passed into the
the template loading methods.
*   `'loader_name'`: An optional string identifying the function or class used
to load the template, e.g. `django.template.loaders.filesystem.Loader`.




## Django模板语言[¶](#the-django-template-language "Permalink to this headline")


### 语法[¶](#syntax "Permalink to this headline")

>关于本节

>这是Django模板语言的语法概述。详细信息请参考[语言语法参考](https://docs.djangoproject.com/en/1.9/ref/templates/language/)。


Django模板是一个简单的文本文档，或使用Django模板语言标记的Python字符串。一些结构被模板引擎识别和解释。主要的有变量和标签。

模板是与上下文一起进行渲染。渲染使用值来替代变量，它在上下文中进行搜索，并执行标签。其他一切原样输出。

Django模板语言的语法包括四个结构。


#### 变量[¶](#variables "Permalink to this headline")

一个变量从上下文中输出值，它是一种类似字典的对象将键映射到值。

变量由`{{` 和 `}}`所包围，像这样：
```html
My first name is {{ first_name }}. My last name is {{ last_name }}.
```

此时，若上下文是`{'first_name': 'John', 'last_name': 'Doe'}`，那么这个模板会渲染成：
```
My first name is John. My last name is Doe.
```

字典查找，属性查找和列表索引查找是用一个点符号来实现的：
```html
{{ my_dict.key }}
{{ my_object.attribute }}
{{ my_list.0 }}
```

如果一个变量解析为一个可调用对象，那么模板系统将不带任何参数来调用它并使用它的结果取而代之。


#### 标签[¶](#tags "Permalink to this headline")

标签提供渲染过程中任意的逻辑。

这个定义是故意模糊。例如，标签可以输出内容，作为一个控制结构，例如，一个“if”语句或“for”循环，从数据库从抽取内容，甚至访问其他的模板标签。

标签像这样被`{%`包围`%}`：
```html
{% csrf_token %}
```

大多数标签接受参数：
```html
{% cycle 'odd' 'even' %}
```

有些标签需要开始和结束标签：
```html
{% if user.is_authenticated %}Hello, {{ user.username }}.{% endif %}
```

[内置标签的指南](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#ref-templates-builtins-tags)如[编写自定义标签的说明](https://docs.djangoproject.com/en/1.9/howto/custom-template-tags/#howto-writing-custom-template-tags)一样可用。


#### 过滤器[¶](#filters "Permalink to this headline")

过滤器转换变量值和标签参数。

它们是这样的：
```html
{{ django|title }}
```

如果上下文是`{'django': 'the web framework for perfectionists with
deadlines'}`那么这个模板将渲染成：
```html
The Web Framework For Perfectionists With Deadlines
```

一些过滤器接受参数：
```html
{{ my_date|date:"Y-m-d" }}
```

[内置过滤器的指南](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#ref-templates-builtins-filters) 与[编写自定义过滤器的说明](https://docs.djangoproject.com/en/1.9/howto/custom-template-tags/#howto-writing-custom-template-filters)一样可用。


#### 评论[¶](#comments "Permalink to this headline")

评论是这样的：
```html
{# this won't be rendered #}
```

[`{% comment %}`](https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#std:templatetag-comment)标签提供多行评论。



### 组件[¶](#components "Permalink to this headline")

>关于本节

>这是Django模板语言API的概述。有关详情请参阅[_API指南_](https://docs.djangoproject.com/en/1.9/ref/templates/api/).


#### 引擎(Engine)[¶](#engine "Permalink to this headline")

[`django.template.Engine`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Engine "django.template.Engine")封装Django模板系统的一个实例。直接实例化一个[`Engine`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Engine "django.template.Engine")的主要原因在于，在Django工程外使用Django模板语言。

[`django.template.backends.django.DjangoTemplates`](#django.template.backends.django.DjangoTemplates "django.template.backends.django.DjangoTemplates")是一个调整[`django.template.Engine`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Engine "django.template.Engine")以适应Django模板后端API的瘦封装器。


#### Template[¶](#template "Permalink to this headline")

[`django.template.Template`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template "django.template.Template")代表已编译模板。通过[`Engine.get_template()`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Engine.get_template "django.template.Engine.get_template")或者 [`Engine.from_string()`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Engine.from_string "django.template.Engine.from_string")可以取得一个Template。

同样的，`django.template.backends.django.Template`是一个调整[`django.template.Template`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template "django.template.Template")以适应通用模板API的瘦封装器。


#### Context[¶](#context "Permalink to this headline")

[`django.template.Context`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Context "django.template.Context")持有除了上下文数据的一些元数据。它被传递给[`Template.render()`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template.render "django.template.Template.render")以渲染模板。

[`django.template.RequestContext`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.RequestContext "django.template.RequestContext")是[`Context`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Context "django.template.Context")的一个子类，它保存当前的[`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest")，并运行模板上下文处理器。

共用API不具有等效的概念。 Context data is passed in a
plain 一个普通的[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(Python v3.5)")传递上下文数据，而如果需要的话，当前[`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest")会被单独传递。


#### 加载器[¶](#loaders "Permalink to this headline")

模板加载器负责定位模板，加载它们，并返回[`Template`](https://docs.djangoproject.com/en/1.9/ref/templates/api/#django.template.Template "django.template.Template")对象。

Django提供了几个[内置的模板加载器](https://docs.djangoproject.com/en/1.9/ref/templates/api/#template-loaders)，并支持[自定义模板加载器](https://docs.djangoproject.com/en/1.9/ref/templates/api/#custom-template-loaders)。


#### 上下文处理器[¶](#context-processors "Permalink to this headline")

上下文处理器是接收当前[`HttpRequest`](https://docs.djangoproject.com/en/1.9/ref/request-response/#django.http.HttpRequest "django.http.HttpRequest")作为参数，并返回数据的一个[`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(Python v3.5)")来添加到渲染上下文的函数。

它们的主要用途是增加所有模板共享的公共数据到上下文中，而无需在每个视图中重复编写代码。

Django提供许多[内置的上下文处理器](https://docs.djangoproject.com/en/1.9/ref/templates/api/#context-processors)。实现自定义的上下文处理器如定义一个函数一样简单。
